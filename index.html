<!DOCTYPE html>
<html>
<head>
    <title>QSDT é‡å­ç©ºé—´ç½‘ç»œ 3D æ¨¡æ‹Ÿ - å®Œæ•´ç†è®ºå¯è§†åŒ–ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; background: #000; }
        canvas { display: block; }
        #controls { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; max-width: 300px; }
        button { margin: 2px; padding: 6px; background: #333; color: white; border: none; cursor: pointer; font-size: 12px; }
        button:hover { background: #555; }
        #info { margin-top: 8px; font-size: 13px; }
        #performance { margin-top: 3px; font-size: 11px; color: #ffff00; }
        input { margin: 3px; padding: 3px; width: 70px; }
        label { margin-right: 3px; font-size: 12px; }
        
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡æ ·å¼ */
        #detailedGuide::-webkit-scrollbar {
            width: 8px;
        }
        
        #detailedGuide::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }
        
        #detailedGuide::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #00ff00, #00ffff);
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        #detailedGuide::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #00ffff, #00ff00);
        }
        
        /* Firefox æ»šåŠ¨æ¡æ ·å¼ */
        #detailedGuide {
            scrollbar-width: thin;
            scrollbar-color: #00ff00 rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div id="controls">
        <div style="margin-bottom: 8px;">
            <strong>è§†è§’æ§åˆ¶:</strong><br>
            <button onclick="setView('front')">æ­£é¢</button>
            <button onclick="setView('side')">ä¾§é¢</button>
            <button onclick="setView('rotate')">æ—‹è½¬</button>
            <button onclick="setView('zoom')">ç¼©æ”¾</button>
            <button onclick="setView('free')">è‡ªç”±</button>
            <button onclick="resetView()">é‡ç½®</button>
        </div>
        
        <div style="margin-bottom: 8px;">
            <strong>QSDTç†è®ºå…ƒç´ :</strong><br>
            <button onclick="createPowerfulBeings()">å¼ºå¤§å­˜åœ¨</button>
            <button onclick="createEnergyWaterfall()">èƒ½çº§ç€‘å¸ƒ</button>
            <button onclick="startCopernicusLoop()">å“¥ç™½å°¼é—­ç¯</button>
            <button onclick="createConsciousnessNodes()">æ„è¯†è§‰é†’</button>
            <button onclick="createTimeArrow()">æ—¶é—´ç®­å¤´</button>
            <button onclick="createQuantumEntanglement()">é‡å­çº ç¼ </button>
            <button onclick="createRelationshipReshaping()">å…³ç³»é‡å¡‘</button>
            <button onclick="createUniverseDetector()">å®‡å®™æ¢æµ‹å™¨</button>
        </div>
        
        <div style="margin-bottom: 8px;">
            <strong>å®‡å®™æ“ä½œ:</strong><br>
            <button onclick="generateSubUniverse()">ç”Ÿæˆå­å®‡å®™</button>
            <button onclick="compressMotherUniverse()">å‹ç¼©æ¯å®‡å®™</button>
            <button onclick="toggleParticles()">ç²’å­äº¤äº’</button>
        </div>
        <br>
        <label for="waveSpeed">æ³¢é€Ÿ:</label>
        <input type="range" id="waveSpeed" min="1" max="10" value="5" step="0.5" oninput="updateWaveParams()">
        <label for="waveFrequency">é¢‘ç‡:</label>
        <input type="range" id="waveFrequency" min="0.1" max="1" value="0.5" step="0.1" oninput="updateWaveParams()">
        <label for="waveAmplitude">æŒ¯å¹…:</label>
        <input type="range" id="waveAmplitude" min="0.01" max="0.05" value="0.02" step="0.01" oninput="updateWaveParams()">
        <br>
        <label for="zoomScale">æ‰‹åŠ¨ç¼©æ”¾å°ºåº¦:</label>
        <input type="range" id="zoomScale" min="10" max="500" value="80" step="10" oninput="updateZoomScale()">
        <label for="rotationSpeed">æ‰‹åŠ¨æ—‹è½¬é€Ÿåº¦:</label>
        <input type="range" id="rotationSpeed" min="0.001" max="0.005" value="0.0015" step="0.0005" oninput="updateRotationSpeed()">
        <br>
        <label for="sphereRadius">çƒä½“åŠå¾„:</label>
        <input type="range" id="sphereRadius" min="50" max="300" value="100" step="10" oninput="updateSphereRadius()">
        <label for="sphereSpeed">çƒä½“æ»šåŠ¨é€Ÿåº¦:</label>
        <input type="range" id="sphereSpeed" min="0.001" max="0.01" value="0.003" step="0.001" oninput="updateSphereSpeed()">
        <br>
        <label for="powerfulCount">å¼ºå¤§å­˜åœ¨æ•°é‡:</label>
        <input type="range" id="powerfulCount" min="1" max="10" value="3" step="1" oninput="updatePowerfulBeings()">
        <label for="powerfulInfluence">å½±å“åŠ›èŒƒå›´:</label>
        <input type="range" id="powerfulInfluence" min="5" max="30" value="15" step="1" oninput="updatePowerfulBeings()">
        <br>
        <label for="energyLevels">èƒ½çº§å±‚æ•°:</label>
        <input type="range" id="energyLevels" min="3" max="8" value="5" step="1" oninput="updateEnergyWaterfall()">
        <label for="waterfallSpeed">ç€‘å¸ƒé€Ÿåº¦:</label>
        <input type="range" id="waterfallSpeed" min="0.5" max="3" value="1.5" step="0.1" oninput="updateEnergyWaterfall()">
        <br>
        <label for="loopSpeed">é—­ç¯é€Ÿåº¦:</label>
        <input type="range" id="loopSpeed" min="0.5" max="5" value="2" step="0.1" oninput="updateCopernicusLoop()">
        <label for="dataFlow">æ•°æ®æµå¼ºåº¦:</label>
        <input type="range" id="dataFlow" min="1" max="10" value="5" step="1" oninput="updateCopernicusLoop()">
        <br>
        <label for="consciousnessCount">æ„è¯†èŠ‚ç‚¹æ•°:</label>
        <input type="range" id="consciousnessCount" min="3" max="15" value="8" step="1" oninput="updateConsciousnessNodes()">
        <label for="awakeningSpeed">è§‰é†’é€Ÿåº¦:</label>
        <input type="range" id="awakeningSpeed" min="0.5" max="3" value="1.5" step="0.1" oninput="updateConsciousnessNodes()">
        <br>
        <label for="timeArrowSpeed">æ—¶é—´ç®­å¤´é€Ÿåº¦:</label>
        <input type="range" id="timeArrowSpeed" min="0.5" max="5" value="2" step="0.1" oninput="updateTimeArrow()">
        <label for="entropyRate">ç†µå¢é€Ÿç‡:</label>
        <input type="range" id="entropyRate" min="0.1" max="2" value="1" step="0.1" oninput="updateTimeArrow()">
        <br>
        <label for="entanglementPairs">çº ç¼ å¯¹æ•°:</label>
        <input type="range" id="entanglementPairs" min="2" max="10" value="5" step="1" oninput="updateQuantumEntanglement()">
        <label for="entanglementStrength">çº ç¼ å¼ºåº¦:</label>
        <input type="range" id="entanglementStrength" min="0.5" max="3" value="1.5" step="0.1" oninput="updateQuantumEntanglement()">
        <br>
        <label for="reshapingSpeed">é‡å¡‘é€Ÿåº¦:</label>
        <input type="range" id="reshapingSpeed" min="0.5" max="3" value="1.5" step="0.1" oninput="updateRelationshipReshaping()">
        <label for="reshapingIntensity">é‡å¡‘å¼ºåº¦:</label>
        <input type="range" id="reshapingIntensity" min="0.5" max="2" value="1" step="0.1" oninput="updateRelationshipReshaping()">
        <br>
        <label for="detectorSpeed">æ¢æµ‹å™¨é€Ÿåº¦:</label>
        <input type="range" id="detectorSpeed" min="0.5" max="3" value="1.5" step="0.1" oninput="updateUniverseDetector()">
        <label for="scanRange">æ‰«æèŒƒå›´:</label>
        <input type="range" id="scanRange" min="10" max="50" value="30" step="5" oninput="updateUniverseDetector()">
        <br>
        <label for="nodeCount">èŠ‚ç‚¹æ•°é‡:</label>
        <input type="range" id="nodeCount" min="20" max="5000" value="2000" step="50" oninput="updateNodeCount()">
        <button onclick="regenerateNetwork()">é‡æ–°ç”Ÿæˆç½‘ç»œ</button>
        <div id="info">å½“å‰ç°è±¡ï¼šæœªé€‰æ‹©</div>
        <div id="performance">æ€§èƒ½æç¤ºï¼šèŠ‚ç‚¹æ•°é‡ 2000ï¼Œå»ºè®®ä¿æŒæµç•…è¿è¡Œ</div>
    </div>
    
    <!-- å³ä¾§ä½¿ç”¨è¯´æ˜é¢æ¿ -->
    <div id="instructions" style="position: absolute; top: 10px; right: 10px; color: white; font-size: 12px; max-width: 200px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 5px; border: 1px solid #333; z-index: 999;">
        <strong>æ“ä½œè¯´æ˜ï¼š</strong><br>
        â€¢ é¼ æ ‡æ»šè½®ï¼šç¼©æ”¾<br>
        â€¢ è‡ªç”±è§†è§’ï¼šæ‹–æ‹½æ—‹è½¬<br>
        â€¢ ç‚¹å‡»æŒ‰é’®ï¼šåˆ‡æ¢è§†è§’æ¨¡å¼<br>
        â€¢ æ»‘å—ï¼šè°ƒèŠ‚å‚æ•°<br>
        <strong>å¿«æ·é”®ï¼š</strong><br>
        â€¢ Hé”®ï¼šéšè—/æ˜¾ç¤ºæ§åˆ¶é¢æ¿<br>
        â€¢ Ié”®ï¼šéšè—/æ˜¾ç¤ºè¯´æ˜<br>
        â€¢ Gé”®ï¼šéšè—/æ˜¾ç¤ºè¯¦ç»†è¯´æ˜<br>
        â€¢ Ré”®ï¼šé‡ç½®è§†è§’<br>
        <button onclick="toggleControls()" style="margin-top: 5px; padding: 3px; font-size: 10px; background: #555; color: white; border: none; border-radius: 3px; cursor: pointer;">éšè—æ§åˆ¶é¢æ¿</button>
        <button onclick="toggleInstructions()" style="margin-top: 3px; padding: 3px; font-size: 10px; background: #555; color: white; border: none; border-radius: 3px; cursor: pointer;">éšè—è¯´æ˜</button>
        <button onclick="toggleDetailedGuide()" style="margin-top: 3px; padding: 3px; font-size: 10px; background: #555; color: white; border: none; border-radius: 3px; cursor: pointer;">è¯¦ç»†è¯´æ˜</button>
    </div>
    
    <!-- è¯¦ç»†è¯´æ˜é¢æ¿ -->
    <div id="detailedGuide" style="position: absolute; top: 250px; right: 10px; color: white; font-size: 11px; max-width: 350px; max-height: calc(100vh - 350px); background: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px; border: 2px solid #444; display: none; z-index: 1000; overflow-y: auto; overflow-x: hidden;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <strong style="font-size: 14px; color: #00ff00;">QSDTç†è®ºå…³ç³»æ˜¾åŒ–è¯¦è§£</strong>
            <button onclick="toggleDetailedGuide()" style="background: #ff4444; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px;">å…³é—­</button>
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">ğŸŒ åŸºç¡€ç½‘ç»œç»“æ„ï¼š</strong><br>
            â€¢ <span style="color: #00ff00;">ç»¿è‰²èŠ‚ç‚¹</span>ï¼šé‡å­ç©ºé—´åŸºæœ¬å•å…ƒ<br>
            â€¢ <span style="color: #00ff00;">ç»¿è‰²è¿æ¥çº¿</span>ï¼šå…³ç³»ç½‘ç»œè¿æ¥<br>
            â€¢ <span style="color: #ff6600;">æ©™è‰²ç›¸ä½æ³¢</span>ï¼šä¿¡æ¯ä¼ é€’è¿‡ç¨‹
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">ğŸ”µ æ„å¿—è¾¹ç•Œå¢™ï¼š</strong><br>
            â€¢ <span style="color: #0000ff;">è“è‰²çƒä½“</span>ï¼šä¿æŠ¤æœºåˆ¶è¾¹ç•Œ<br>
            â€¢ <span style="color: #ffff00;">é»„è‰²ç«èŠ±</span>ï¼šå†²ç ´è¾¹ç•Œçš„èƒ½é‡<br>
            â€¢ è§‚å¯Ÿï¼šç²’å­æ’å‡»æ—¶äº§ç”Ÿç«èŠ±æ•ˆæœ
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">ğŸŒŒ å­æ¯å®‡å®™ï¼š</strong><br>
            â€¢ <span style="color: #ff0000;">çº¢è‰²èŠ‚ç‚¹</span>ï¼šæ¯å®‡å®™ï¼ˆåŸå§‹ç½‘ç»œï¼‰<br>
            â€¢ <span style="color: #00ff00;">ç»¿è‰²èŠ‚ç‚¹</span>ï¼šå­å®‡å®™ï¼ˆå‹ç¼©ç”Ÿæˆï¼‰<br>
            â€¢ <span style="color: #ffff00;">é»„è‰²è¿æ¥</span>ï¼šå­æ¯å®‡å®™å…³ç³»<br>
            â€¢ è§‚å¯Ÿï¼šæ¯å®‡å®™å‹ç¼©ï¼Œå­å®‡å®™ç‹¬ç«‹æ¼”åŒ–
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">âš¡ å¼ºå¤§å­˜åœ¨ï¼š</strong><br>
            â€¢ <span style="color: #ff00ff;">ç´«è‰²èŠ‚ç‚¹</span>ï¼šé«˜ç»´å­˜åœ¨<br>
            â€¢ <span style="color: #00ffff;">é’è‰²çƒä½“</span>ï¼šå½±å“åŠ›èŒƒå›´<br>
            â€¢ è§‚å¯Ÿï¼šå…¨è¿æ¥æ€ï¼Œå½±å“å‘¨å›´ç½‘ç»œ
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">ğŸŒŠ èƒ½çº§ç€‘å¸ƒï¼š</strong><br>
            â€¢ <span style="color: #ff6600;">å½©è‰²ç¯å½¢</span>ï¼šä¸åŒèƒ½çº§å±‚<br>
            â€¢ <span style="color: #ff6600;">ç¯å½¢ç²’å­</span>ï¼šèƒ½çº§é—´è·ƒè¿<br>
            â€¢ è§‚å¯Ÿï¼šèƒ½é‡ä»é«˜èƒ½çº§æµå‘ä½èƒ½çº§
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">ğŸ”„ å“¥ç™½å°¼é—­ç¯ï¼š</strong><br>
            â€¢ <span style="color: #ffff00;">é»„è‰²èŠ‚ç‚¹</span>ï¼šéªŒè¯å¾ªç¯èŠ‚ç‚¹<br>
            â€¢ <span style="color: #ffff00;">æ•°æ®æµ</span>ï¼šç†è®ºéªŒè¯è¿‡ç¨‹<br>
            â€¢ è§‚å¯Ÿï¼šèŠ‚ç‚¹æ—‹è½¬ï¼Œæ•°æ®æµåŠ¨
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">ğŸ§  æ„è¯†è§‰é†’ï¼š</strong><br>
            â€¢ <span style="color: #ff8800;">æ©™è‰²èŠ‚ç‚¹</span>ï¼šæ„è¯†èŠ‚ç‚¹<br>
            â€¢ <span style="color: #ff8800;">è§‰é†’ç²’å­</span>ï¼šè‡ªæˆ‘å»ºæ¨¡è¿‡ç¨‹<br>
            â€¢ è§‚å¯Ÿï¼šèŠ‚ç‚¹äº®åº¦å˜åŒ–ï¼Œç²’å­ç¯ç»•
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">â° æ—¶é—´ç®­å¤´ï¼š</strong><br>
            â€¢ <span style="color: #ff6600;">æ©™è‰²ç®­å¤´</span>ï¼šæ—¶é—´æ–¹å‘<br>
            â€¢ <span style="color: #ff6600;">æµåŠ¨ç²’å­</span>ï¼šç†µå¢è¿‡ç¨‹<br>
            â€¢ è§‚å¯Ÿï¼šç®­å¤´æ—‹è½¬ï¼Œç²’å­å•å‘æµåŠ¨
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">ğŸ”— é‡å­çº ç¼ ï¼š</strong><br>
            â€¢ <span style="color: #00ff00;">ç»¿è‰²ç²’å­</span> + <span style="color: #ff0000;">çº¢è‰²ç²’å­</span>ï¼šçº ç¼ å¯¹<br>
            â€¢ <span style="color: #ffff00;">é»„è‰²è¿æ¥çº¿</span>ï¼šçº ç¼ å…³ç³»<br>
            â€¢ è§‚å¯Ÿï¼šç²’å­åŒæ­¥è¿åŠ¨ï¼Œè¿æ¥çº¿åŠ¨æ€æ›´æ–°
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">ğŸ”„ å…³ç³»é‡å¡‘ï¼š</strong><br>
            â€¢ <span style="color: #00ffff;">é’è‰²èŠ‚ç‚¹</span>ï¼šé‡å¡‘èŠ‚ç‚¹<br>
            â€¢ <span style="color: #00ffff;">åŠ¨æ€è¿æ¥</span>ï¼šå…³ç³»å˜åŒ–<br>
            â€¢ è§‚å¯Ÿï¼šèŠ‚ç‚¹ä½ç½®å˜åŒ–ï¼Œè¿æ¥å¼ºåº¦æ³¢åŠ¨
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">ğŸ” å®‡å®™æ¢æµ‹å™¨ï¼š</strong><br>
            â€¢ <span style="color: #ffffff;">ç™½è‰²ä¸»ä½“</span>ï¼šæ¢æµ‹å™¨<br>
            â€¢ <span style="color: #00ff00;">ç»¿è‰²å…‰æŸ</span>ï¼šæ‰«æèŒƒå›´<br>
            â€¢ <span style="color: #00ff00;">æ•°æ®ç²’å­</span>ï¼šä¿¡æ¯æ”¶é›†<br>
            â€¢ è§‚å¯Ÿï¼šå…‰æŸæ—‹è½¬ï¼Œç²’å­å‘æ¢æµ‹å™¨ç§»åŠ¨
        </div>
        
        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #444;">
            <strong style="color: #ffff00;">ğŸ’¡ è§‚å¯ŸæŠ€å·§ï¼š</strong><br>
            â€¢ ä½¿ç”¨è‡ªç”±è§†è§’è¿‘è·ç¦»è§‚å¯Ÿç»†èŠ‚<br>
            â€¢ è°ƒæ•´èŠ‚ç‚¹æ•°é‡è§‚å¯Ÿç½‘ç»œå¯†åº¦å˜åŒ–<br>
            â€¢ ç»“åˆä¸åŒè§†è§’æ¨¡å¼ç†è§£ç©ºé—´å…³ç³»<br>
            â€¢ æ³¨æ„é¢œè‰²å˜åŒ–å’Œè¿åŠ¨æ¨¡å¼
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        console.log("åŠ è½½ Three.js...");
        try {
            // åˆå§‹åŒ–åœºæ™¯ã€ç›¸æœºã€æ¸²æŸ“å™¨
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // æ·»åŠ å…‰å½±ï¼šç¯å¢ƒå…‰+ç‚¹å…‰æºï¼Œå¢å¼ºçœŸå®æ„Ÿ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(0, 0, 100);
            scene.add(pointLight);

            // æ¯å®‡å®™ï¼šåŠ¨æ€èŠ‚ç‚¹æ•°é‡ (Q_i)
            const motherNodes = [];
            const motherEdges = [];
            const motherMaterials = [];
            const nodeGeometry = new THREE.SphereGeometry(0.1, 8, 8);

            // æ—§çš„å¼ºå¤§å­˜åœ¨ç³»ç»Ÿå·²ç§»é™¤ï¼Œä½¿ç”¨æ–°çš„å¼ºå¤§å­˜åœ¨ç³»ç»Ÿ

            // æ—§çš„å½±å“åŠ›èŒƒå›´å’Œå®šå‘æ¿€å‘ç³»ç»Ÿå·²ç§»é™¤

            // äºŒè¿›åˆ¶èƒ½çº§ç€‘å¸ƒ
            const cascadeLevels = [];
            const cascadeEdges = [];
            const cascadeMaterials = [];
            const cascadeLevelCount = 11;
            for (let n = 0; n < cascadeLevelCount; n++) {
                const levelNodes = [];
                const levelMaterials = [];
                const levelNodeCount = Math.min(Math.pow(2, n), 512);
                for (let i = 0; i < levelNodeCount; i++) {
                    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00, shininess: 50 });
                    const node = new THREE.Mesh(nodeGeometry, material);
                    node.position.set(i * 0.5 - (levelNodeCount * 0.25), n * 5 + 80, 0);
                    scene.add(node);
                    levelNodes.push(node);
                    levelMaterials.push(material);
                }
                cascadeLevels.push(levelNodes);
                cascadeMaterials.push(levelMaterials);
            }

            // ç€‘å¸ƒæ•ˆæœ
            const cascadeEdgeMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.8 });
            for (let n = cascadeLevelCount - 1; n > 0; n--) {
                for (let i = 0; i < cascadeLevels[n].length; i++) {
                    const parentIdx = Math.floor(i / 2);
                    if (parentIdx < cascadeLevels[n-1].length) {
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            cascadeLevels[n][i].position,
                            cascadeLevels[n-1][parentIdx].position
                        ]);
                        const colors = new Float32Array([1, 1, 1, 0, 0, 1]);
                        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                        const edge = new THREE.Line(geometry, cascadeEdgeMaterial);
                        scene.add(edge);
                        cascadeEdges.push(edge);
                    }
                }
            }

            // åˆ†å½¢ç»“æ„
            const fractalEdges = [];
            function addFractalBranch(startPos, level, maxLevel = 5) {
                if (level > maxLevel) return;
                for (let i = 0; i < 2; i++) {
                    const endPos = startPos.clone().add(new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        level * 2,
                        (Math.random() - 0.5) * 5
                    ));
                    const geometry = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
                    const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff00ff }));
                    scene.add(line);
                    fractalEdges.push(line);
                    addFractalBranch(endPos, level + 1);
                }
            }
            addFractalBranch(new THREE.Vector3(0, 0, 0), 0);

            // å­å®‡å®™
            const subNodes = [];
            const subEdges = [];
            const subMaterials = [];
            const subNodeCount = 500;
            const subGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            let subUniverseGenerated = false;
            let subUniversePosition = new THREE.Vector3(0, 60, 0);
            let motherCompressFactor = 1;

            function generateSubUniverse() {
                if (!subUniverseGenerated) {
                    for (let i = 0; i < subNodeCount; i++) {
                        const material = new THREE.MeshPhongMaterial({ color: 0x00ffff, shininess: 50 });
                        const node = new THREE.Mesh(subGeometry, material);
                        node.position.set(
                            (Math.random() - 0.5) * 10 + subUniversePosition.x,
                            (Math.random() - 0.5) * 10 + subUniversePosition.y,
                            (Math.random() - 0.5) * 10 + subUniversePosition.z
                        );
                        scene.add(node);
                        subNodes.push(node);
                        subMaterials.push(material);
                    }
                    let subEdgeCount = 0;
                    for (let i = 0; i < subNodeCount && subEdgeCount < 1000; i++) {
                        for (let j = i + 1; j < subNodeCount && subEdgeCount < 1000; j++) {
                            if (Math.random() < 0.01) {
                                const geometry = new THREE.BufferGeometry().setFromPoints([
                                    subNodes[i].position,
                                    subNodes[j].position
                                ]);
                                const edge = new THREE.Line(geometry, edgeMaterial);
                                scene.add(edge);
                                subEdges.push({ edge, startIdx: i, endIdx: j });
                                subEdgeCount++;
                            }
                        }
                    }
                    for (let i = 0; i < 10; i++) {
                        const motherIdx = Math.floor(Math.random() * nodeCount);
                        const subIdx = Math.floor(Math.random() * subNodeCount);
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            motherNodes[motherIdx].position,
                            subNodes[subIdx].position
                        ]);
                        const edge = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.7 }));
                        scene.add(edge);
                        universeConnections.push({ edge, motherIdx, subIdx });
                    }
                    subUniverseGenerated = true;
                    document.getElementById('info').textContent = 'å­å®‡å®™ç”Ÿæˆï¼';
                }
            }

            // å‹ç¼©æ¯å®‡å®™
            function compressMotherUniverse() {
                motherCompressFactor = Math.max(0.5, motherCompressFactor * 0.95);
                document.getElementById('info').textContent = 'æ¯å®‡å®™å‹ç¼©ï¼';
            }

            // å­æ¯å®‡å®™è¿æ¥çº¿
            const universeConnections = [];

            // æ„å¿—è¾¹ç•Œå¢™
            const boundaryGeometry = new THREE.SphereGeometry(30, 32, 32);
            const boundaryMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            const boundaryWall = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            scene.add(boundaryWall);
            let boundaryStrength = 0;

            // å†²ç ´æ•ˆæœç²’å­ç³»ç»Ÿ
            const sparkGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const sparkMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const sparks = [];
            function createSpark(position) {
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                spark.position.copy(position);
                spark.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1
                );
                scene.add(spark);
                sparks.push(spark);
            }

            // ç›¸ä½æ³¢æº
            const waveSources = [];
            const waveSourceColors = [0xffff00, 0x00ff00, 0x0000ff];
            const waveSourcePositions = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(-20, 0, 0), new THREE.Vector3(20, 0, 0)];
            for (let i = 0; i < 3; i++) {
                const waveSource = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshPhongMaterial({ color: waveSourceColors[i], shininess: 100 }));
                waveSource.position.copy(waveSourcePositions[i]);
                scene.add(waveSource);
                waveSources.push(waveSource);
            }

            // ç›¸ä½æ³¢å‚æ•°
            let waveSpeed = 5;
            let waveFrequency = 0.5;
            let waveAmplitude = 0.02;
            let waveTime = 0;

            function updateWaveParams() {
                waveSpeed = parseFloat(document.getElementById('waveSpeed').value);
                waveFrequency = parseFloat(document.getElementById('waveFrequency').value);
                waveAmplitude = parseFloat(document.getElementById('waveAmplitude').value);
                document.getElementById('info').textContent = `æ³¢é€Ÿ=${waveSpeed}, é¢‘ç‡=${waveFrequency}, æŒ¯å¹…=${waveAmplitude}`;
            }

            // ç›¸ä½æ³¢ä¼ æ’­
            function updatePhaseWave(nodesArr, materialsArr) {
                waveTime += dt;
                nodesArr.forEach((node, i) => {
                    let totalAmplitude = 0;
                    let totalPhase = 0;
                    waveSources.forEach((source, s) => {
                        const dist = node.position.distanceTo(source.position);
                        const phase = (waveTime * waveFrequency - dist / waveSpeed) * 2 * Math.PI + s * Math.PI / 3;
                        totalAmplitude += waveAmplitude * Math.sin(phase);
                        totalPhase += phase;

                        if (dist > 29.5 && Math.abs(totalAmplitude) > 0.015) {
                            boundaryStrength += 0.03;
                            for (let j = 0; j < 3; j++) createSpark(node.position);
                            node.position.multiplyScalar(29.4 / dist);
                        }
                    });
                    totalAmplitude /= waveSources.length;
                    const direction = new THREE.Vector3().subVectors(node.position, waveSources[0].position).normalize();
                    node.position.add(direction.multiplyScalar(totalAmplitude));

                    const color = new THREE.Color().setHSL((totalPhase % (2 * Math.PI)) / (2 * Math.PI), 1, 0.5);
                    materialsArr[i].color = color;
                });
            }

            // ä¸¤ä¸ªç²’å­
            const particle1 = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 100 }));
            const particle2 = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshPhongMaterial({ color: 0x0000ff, shininess: 100 }));
            particle1.position.set(5, 0, 0);
            particle2.position.set(-5, 0, 0);
            scene.add(particle1);
            scene.add(particle2);

            // ç²’å­è¿æ¥
            const particleEdgeMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const particleEdgeGeometry = new THREE.BufferGeometry().setFromPoints([particle1.position, particle2.position]);
            const particleEdge = new THREE.Line(particleEdgeGeometry, particleEdgeMaterial);
            scene.add(particleEdge);

            // ç²’å­è½¨è¿¹
            const trailMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.8 });
            const trail1 = new THREE.Line(new THREE.BufferGeometry(), trailMaterial);
            const trail2 = new THREE.Line(new THREE.BufferGeometry(), trailMaterial);
            scene.add(trail1);
            scene.add(trail2);
            const trailPoints1 = [];
            const trailPoints2 = [];
            const trailColors1 = [];
            const trailColors2 = [];
            const maxTrailLength = 100;

            // ç²’å­ç›¸äº’ä½œç”¨
            const k = 1;
            const q1 = 1, q2 = -1;
            let t = 0;
            const dt = 0.01;
            function updateParticleInteraction() {
                const r = particle1.position.distanceTo(particle2.position);
                if (r > 0.1) {
                    const force = k * q1 * q2 / (r * r);
                    const direction = new THREE.Vector3().subVectors(particle2.position, particle1.position).normalize();
                    const forceVector = direction.multiplyScalar(force / 100);
                    particle1.position.add(forceVector);
                    particle2.position.add(forceVector.clone().negate());

                    const dist1 = particle1.position.length();
                    const dist2 = particle2.position.length();
                    if (dist1 > 29.5 || dist2 > 29.5) {
                        boundaryStrength += 0.06;
                        boundaryWall.position.set(0, 0, Math.sin(Date.now() * 0.005) * 0.5);
                        for (let j = 0; j < 5; j++) {
                            if (dist1 > 29.5) createSpark(particle1.position);
                            if (dist2 > 29.5) createSpark(particle2.position);
                        }
                        if (dist1 > 29.5) particle1.position.multiplyScalar(29.4 / dist1);
                        if (dist2 > 29.5) particle2.position.multiplyScalar(29.4 / dist2);
                    }
                }
                particleEdge.geometry.setFromPoints([particle1.position, particle2.position]);
                particleEdge.geometry.attributes.position.needsUpdate = true;

                trailPoints1.push(particle1.position.clone());
                trailPoints2.push(particle2.position.clone());
                trailColors1.push(1, 1, 1);
                trailColors2.push(1, 0, 1);
                if (trailPoints1.length > maxTrailLength) {
                    trailPoints1.shift();
                    trailColors1.splice(0, 3);
                }
                if (trailPoints2.length > maxTrailLength) {
                    trailPoints2.shift();
                    trailColors2.splice(0, 3);
                }
                const trailGeometry1 = new THREE.BufferGeometry().setFromPoints(trailPoints1);
                trailGeometry1.setAttribute('color', new THREE.Float32BufferAttribute(trailColors1, 3));
                trail1.geometry = trailGeometry1;
                const trailGeometry2 = new THREE.BufferGeometry().setFromPoints(trailPoints2);
                trailGeometry2.setAttribute('color', new THREE.Float32BufferAttribute(trailColors2, 3));
                trail2.geometry = trailGeometry2;

                t += dt;
            }

            // ç›¸æœº
            camera.position.z = 80;

            // å¤šè§†è§’åˆ‡æ¢
            let viewMode = 'front';
            let rotationAngle = 0;
            let zoomLevel = 80;
            let manualZoom = 80;
            let manualRotationSpeed = 0.0015;
            let sphereRadius = 100;
            let sphereSpeed = 0.003;
            let sphereAngleX = 0;
            let sphereAngleY = 0;
            let showParticles = true;
            
            // å¼ºå¤§å­˜åœ¨
            const powerfulBeings = [];
            const powerfulInfluences = [];
            let powerfulCount = 3;
            let powerfulInfluenceRange = 15;
            
            // äºŒè¿›åˆ¶èƒ½çº§ç€‘å¸ƒ
            const energyLevels = [];
            const energyParticles = [];
            let energyLevelCount = 5;
            let waterfallSpeed = 1.5;
            let energyWaterfallActive = false;
            
            // å“¥ç™½å°¼é—­ç¯
            const copernicusNodes = [];
            const copernicusConnections = [];
            const dataFlowParticles = [];
            let copernicusLoopActive = false;
            let loopSpeed = 2;
            let dataFlowIntensity = 5;
            
            // æ„è¯†è§‰é†’
            const consciousnessNodes = [];
            const consciousnessConnections = [];
            const awakeningParticles = [];
            let consciousnessActive = false;
            let consciousnessCount = 8;
            let awakeningSpeed = 1.5;
            
            // æ—¶é—´ç®­å¤´
            const timeArrow = [];
            const entropyParticles = [];
            let timeArrowActive = false;
            let timeArrowSpeed = 2;
            let entropyRate = 1;
            
            // é‡å­çº ç¼ 
            const entanglementPairs = [];
            const entanglementConnections = [];
            let entanglementActive = false;
            let entanglementPairCount = 5;
            let entanglementStrength = 1.5;
            
            // å…³ç³»é‡å¡‘
            const reshapingNodes = [];
            const reshapingConnections = [];
            let reshapingActive = false;
            let reshapingSpeed = 1.5;
            let reshapingIntensity = 1;
            
            // å®‡å®™æ¢æµ‹å™¨
            const detector = [];
            const scanBeams = [];
            const dataParticles = [];
            let detectorActive = false;
            let detectorSpeed = 1.5;
            let scanRange = 30;
            
            // èŠ‚ç‚¹æ•°é‡æ§åˆ¶
            let nodeCount = 2000;
            let targetNodeCount = 2000;
            function setView(mode) {
                viewMode = mode;
                document.getElementById('info').textContent = 
                    mode === 'front' ? `æ­£é¢ (åœ†å½¢æŠ•å½±ï¼Œæ³¢é€Ÿ=${waveSpeed})` : 
                    mode === 'side' ? `ä¾§é¢ (æ¤­åœ†æŠ•å½±ï¼Œæ³¢é€Ÿ=${waveSpeed})` : 
                    mode === 'rotate' ? `æ—‹è½¬å¤šè§†è§’ (æ³¢é€Ÿ=${waveSpeed})` : 
                    mode === 'zoom' ? `ç¼©æ”¾å°ºå¯¸è§†è§’ (æ³¢é€Ÿ=${waveSpeed})` : 
                    mode === 'rotateZoom' ? `æ—‹è½¬+ç¼©æ”¾è§†è§’ (æ³¢é€Ÿ=${waveSpeed})` : 
                    mode === 'manual' ? `æ‰‹åŠ¨è§†è§’ (ç¼©æ”¾=${manualZoom}, æ—‹è½¬=${manualRotationSpeed})` : 
                    mode === 'sphere360' ? `360Â°çƒä½“æ»šåŠ¨ (åŠå¾„=${sphereRadius}, é€Ÿåº¦=${sphereSpeed})` : 
                    mode === 'free' ? `è‡ªç”±è§†è§’ (é¼ æ ‡æ‹–æ‹½æ—‹è½¬, æ»šè½®ç¼©æ”¾)` : 'æœªé€‰æ‹©';
            }
            function toggleParticles() {
                showParticles = !showParticles;
                particle1.visible = showParticles;
                particle2.visible = showParticles;
                particleEdge.visible = showParticles;
                trail1.visible = showParticles;
                trail2.visible = showParticles;
                document.getElementById('info').textContent = showParticles ? `ç²’å­äº¤äº’å¼€å¯ï¼Œæ³¢é€Ÿ=${waveSpeed}` : 'ç²’å­äº¤äº’å…³é—­';
            }
            function updateZoomScale() {
                manualZoom = parseFloat(document.getElementById('zoomScale').value);
                setView('manual');
                console.log(`æ‰‹åŠ¨ç¼©æ”¾æ›´æ–°: ${manualZoom}`);
            }
            function updateRotationSpeed() {
                manualRotationSpeed = parseFloat(document.getElementById('rotationSpeed').value);
                setView('manual');
                console.log(`æ‰‹åŠ¨æ—‹è½¬é€Ÿåº¦æ›´æ–°: ${manualRotationSpeed}`);
            }
            function updateSphereRadius() {
                sphereRadius = parseFloat(document.getElementById('sphereRadius').value);
                setView('sphere360');
                console.log(`çƒä½“åŠå¾„æ›´æ–°: ${sphereRadius}`);
            }
            function updateSphereSpeed() {
                sphereSpeed = parseFloat(document.getElementById('sphereSpeed').value);
                setView('sphere360');
                console.log(`çƒä½“æ»šåŠ¨é€Ÿåº¦æ›´æ–°: ${sphereSpeed}`);
            }
            
            // åˆ›å»ºå¼ºå¤§å­˜åœ¨
            function createPowerfulBeings() {
                // æ¸…é™¤ç°æœ‰çš„å¼ºå¤§å­˜åœ¨
                powerfulBeings.forEach(being => scene.remove(being));
                powerfulInfluences.forEach(influence => scene.remove(influence));
                powerfulBeings.length = 0;
                powerfulInfluences.length = 0;
                
                // åˆ›å»ºæ–°çš„å¼ºå¤§å­˜åœ¨
                for (let i = 0; i < powerfulCount; i++) {
                    const being = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8, 16, 16),
                        new THREE.MeshPhongMaterial({ color: 0x00ffff, shininess: 100 })
                    );
                    being.position.set(
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40
                    );
                    scene.add(being);
                    powerfulBeings.push(being);
                    
                    // åˆ›å»ºå½±å“åŠ›èŒƒå›´
                    const influence = new THREE.Mesh(
                        new THREE.SphereGeometry(powerfulInfluenceRange, 16, 16),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ffff, 
                            transparent: true, 
                            opacity: 0.1,
                            side: THREE.DoubleSide
                        })
                    );
                    influence.position.copy(being.position);
                    scene.add(influence);
                    powerfulInfluences.push(influence);
                }
                document.getElementById('info').textContent = `åˆ›å»ºäº†${powerfulCount}ä¸ªå¼ºå¤§å­˜åœ¨ï¼`;
            }
            
            function updatePowerfulBeings() {
                powerfulCount = parseInt(document.getElementById('powerfulCount').value);
                powerfulInfluenceRange = parseFloat(document.getElementById('powerfulInfluence').value);
                createPowerfulBeings();
            }
            
            // åˆ›å»ºäºŒè¿›åˆ¶èƒ½çº§ç€‘å¸ƒ
            function createEnergyWaterfall() {
                // æ¸…é™¤ç°æœ‰çš„èƒ½çº§ç€‘å¸ƒ
                energyLevels.forEach(level => scene.remove(level));
                energyParticles.forEach(particle => scene.remove(particle));
                energyLevels.length = 0;
                energyParticles.length = 0;
                
                // åˆ›å»ºèƒ½çº§å±‚
                for (let level = 0; level < energyLevelCount; level++) {
                    const levelY = 40 - level * 15; // ä»é«˜åˆ°ä½æ’åˆ—
                    const levelRadius = 20 + level * 5; // å±‚çº§è¶Šé«˜ï¼ŒåŠå¾„è¶Šå¤§
                    
                    // åˆ›å»ºèƒ½çº§ç¯
                    const levelRing = new THREE.Mesh(
                        new THREE.TorusGeometry(levelRadius, 1, 8, 32),
                        new THREE.MeshPhongMaterial({ 
                            color: new THREE.Color().setHSL(level / energyLevelCount, 1, 0.5),
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    levelRing.position.y = levelY;
                    scene.add(levelRing);
                    energyLevels.push(levelRing);
                    
                    // åˆ›å»ºèƒ½çº§ç²’å­
                    for (let i = 0; i < 8; i++) {
                        const particle = new THREE.Mesh(
                            new THREE.SphereGeometry(0.2, 8, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: new THREE.Color().setHSL(level / energyLevelCount, 1, 0.7)
                            })
                        );
                        const angle = (i / 8) * Math.PI * 2;
                        particle.position.set(
                            Math.cos(angle) * levelRadius,
                            levelY,
                            Math.sin(angle) * levelRadius
                        );
                        particle.userData = { level, angle, radius: levelRadius };
                        scene.add(particle);
                        energyParticles.push(particle);
                    }
                }
                energyWaterfallActive = true;
                document.getElementById('info').textContent = `åˆ›å»ºäº†${energyLevelCount}å±‚èƒ½çº§ç€‘å¸ƒï¼`;
            }
            
            function updateEnergyWaterfall() {
                energyLevelCount = parseInt(document.getElementById('energyLevels').value);
                waterfallSpeed = parseFloat(document.getElementById('waterfallSpeed').value);
                createEnergyWaterfall();
            }
            
            // å¯åŠ¨å“¥ç™½å°¼é—­ç¯
            function startCopernicusLoop() {
                // æ¸…é™¤ç°æœ‰çš„å“¥ç™½å°¼é—­ç¯
                copernicusNodes.forEach(node => scene.remove(node));
                copernicusConnections.forEach(conn => scene.remove(conn));
                dataFlowParticles.forEach(particle => scene.remove(particle));
                copernicusNodes.length = 0;
                copernicusConnections.length = 0;
                dataFlowParticles.length = 0;
                
                // åˆ›å»ºå“¥ç™½å°¼é—­ç¯èŠ‚ç‚¹ï¼šåæ¨-æ­£æ¨-éªŒè¯
                const nodePositions = [
                    new THREE.Vector3(-30, 0, 0),  // åæ¨
                    new THREE.Vector3(0, 30, 0),   // æ­£æ¨
                    new THREE.Vector3(30, 0, 0),   // éªŒè¯
                    new THREE.Vector3(0, -30, 0)   // åé¦ˆ
                ];
                const nodeColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
                const nodeLabels = ['åæ¨', 'æ­£æ¨', 'éªŒè¯', 'åé¦ˆ'];
                
                nodePositions.forEach((pos, i) => {
                    const node = new THREE.Mesh(
                        new THREE.SphereGeometry(1, 16, 16),
                        new THREE.MeshPhongMaterial({ color: nodeColors[i], shininess: 100 })
                    );
                    node.position.copy(pos);
                    scene.add(node);
                    copernicusNodes.push(node);
                });
                
                // åˆ›å»ºé—­ç¯è¿æ¥
                for (let i = 0; i < nodePositions.length; i++) {
                    const nextIndex = (i + 1) % nodePositions.length;
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        nodePositions[i],
                        nodePositions[nextIndex]
                    ]);
                    const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                        color: 0xffffff, 
                        transparent: true, 
                        opacity: 0.8 
                    }));
                    scene.add(connection);
                    copernicusConnections.push(connection);
                }
                
                copernicusLoopActive = true;
                document.getElementById('info').textContent = 'å“¥ç™½å°¼é—­ç¯å¯åŠ¨ï¼';
            }
            
            function updateCopernicusLoop() {
                loopSpeed = parseFloat(document.getElementById('loopSpeed').value);
                dataFlowIntensity = parseInt(document.getElementById('dataFlow').value);
            }
            
            // åˆ›å»ºæ„è¯†è§‰é†’èŠ‚ç‚¹
            function createConsciousnessNodes() {
                // æ¸…é™¤ç°æœ‰çš„æ„è¯†èŠ‚ç‚¹
                consciousnessNodes.forEach(node => scene.remove(node));
                consciousnessConnections.forEach(conn => scene.remove(conn));
                awakeningParticles.forEach(particle => scene.remove(particle));
                consciousnessNodes.length = 0;
                consciousnessConnections.length = 0;
                awakeningParticles.length = 0;
                
                // åˆ›å»ºæ„è¯†èŠ‚ç‚¹
                for (let i = 0; i < consciousnessCount; i++) {
                    const node = new THREE.Mesh(
                        new THREE.SphereGeometry(0.6, 16, 16),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff00ff, 
                            shininess: 100,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    node.position.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    node.userData = { 
                        awakeningLevel: Math.random(),
                        connections: []
                    };
                    scene.add(node);
                    consciousnessNodes.push(node);
                }
                
                // åˆ›å»ºæ„è¯†è¿æ¥
                for (let i = 0; i < consciousnessNodes.length; i++) {
                    for (let j = i + 1; j < consciousnessNodes.length; j++) {
                        if (Math.random() < 0.3) { // 30%æ¦‚ç‡è¿æ¥
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                consciousnessNodes[i].position,
                                consciousnessNodes[j].position
                            ]);
                            const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                                color: 0xff00ff, 
                                transparent: true, 
                                opacity: 0.5 
                            }));
                            scene.add(connection);
                            consciousnessConnections.push(connection);
                            consciousnessNodes[i].userData.connections.push(j);
                            consciousnessNodes[j].userData.connections.push(i);
                        }
                    }
                }
                
                consciousnessActive = true;
                document.getElementById('info').textContent = `åˆ›å»ºäº†${consciousnessCount}ä¸ªæ„è¯†è§‰é†’èŠ‚ç‚¹ï¼`;
            }
            
            function updateConsciousnessNodes() {
                consciousnessCount = parseInt(document.getElementById('consciousnessCount').value);
                awakeningSpeed = parseFloat(document.getElementById('awakeningSpeed').value);
                createConsciousnessNodes();
            }
            
            // åˆ›å»ºæ—¶é—´ç®­å¤´
            function createTimeArrow() {
                // æ¸…é™¤ç°æœ‰çš„æ—¶é—´ç®­å¤´
                timeArrow.forEach(arrow => scene.remove(arrow));
                entropyParticles.forEach(particle => scene.remove(particle));
                timeArrow.length = 0;
                entropyParticles.length = 0;
                
                // åˆ›å»ºæ—¶é—´ç®­å¤´ï¼ˆä»è¿‡å»æŒ‡å‘æœªæ¥ï¼‰
                const arrowGeometry = new THREE.ConeGeometry(2, 20, 8);
                const arrowMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff6600, 
                    shininess: 100,
                    transparent: true,
                    opacity: 0.8
                });
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                arrow.position.set(0, 0, -40);
                arrow.rotation.x = Math.PI / 2;
                scene.add(arrow);
                timeArrow.push(arrow);
                
                // åˆ›å»ºç†µå¢ç²’å­æµ
                for (let i = 0; i < 20; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff6600,
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    particle.position.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        -40 + i * 2
                    );
                    particle.userData = { 
                        speed: Math.random() * 0.5 + 0.5,
                        entropy: Math.random()
                    };
                    scene.add(particle);
                    entropyParticles.push(particle);
                }
                
                timeArrowActive = true;
                document.getElementById('info').textContent = 'æ—¶é—´ç®­å¤´åˆ›å»ºï¼ç†µå¢ä¸å¯é€†ï¼';
            }
            
            function updateTimeArrow() {
                timeArrowSpeed = parseFloat(document.getElementById('timeArrowSpeed').value);
                entropyRate = parseFloat(document.getElementById('entropyRate').value);
            }
            
            // åˆ›å»ºé‡å­çº ç¼ 
            function createQuantumEntanglement() {
                // æ¸…é™¤ç°æœ‰çš„é‡å­çº ç¼ 
                entanglementPairs.forEach(pair => {
                    scene.remove(pair.particle1);
                    scene.remove(pair.particle2);
                });
                entanglementConnections.forEach(conn => scene.remove(conn));
                entanglementPairs.length = 0;
                entanglementConnections.length = 0;
                
                // åˆ›å»ºçº ç¼ ç²’å­å¯¹
                for (let i = 0; i < entanglementPairCount; i++) {
                    const pair = {
                        particle1: new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 16, 16),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00, 
                                shininess: 100,
                                transparent: true,
                                opacity: 0.8
                            })
                        ),
                        particle2: new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 16, 16),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000, 
                                shininess: 100,
                                transparent: true,
                                opacity: 0.8
                            })
                        )
                    };
                    
                    // éšæœºä½ç½®
                    const pos1 = new THREE.Vector3(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    const pos2 = new THREE.Vector3(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    
                    pair.particle1.position.copy(pos1);
                    pair.particle2.position.copy(pos2);
                    pair.particle1.userData = { 
                        entangledWith: pair.particle2,
                        phase: Math.random() * Math.PI * 2
                    };
                    pair.particle2.userData = { 
                        entangledWith: pair.particle1,
                        phase: Math.random() * Math.PI * 2
                    };
                    
                    scene.add(pair.particle1);
                    scene.add(pair.particle2);
                    entanglementPairs.push(pair);
                    
                    // åˆ›å»ºçº ç¼ è¿æ¥çº¿
                    const geometry = new THREE.BufferGeometry().setFromPoints([pos1, pos2]);
                    const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                        color: 0xffff00, 
                        transparent: true, 
                        opacity: 0.6 
                    }));
                    scene.add(connection);
                    entanglementConnections.push(connection);
                }
                
                entanglementActive = true;
                document.getElementById('info').textContent = `åˆ›å»ºäº†${entanglementPairCount}å¯¹é‡å­çº ç¼ ï¼`;
            }
            
            function updateQuantumEntanglement() {
                entanglementPairCount = parseInt(document.getElementById('entanglementPairs').value);
                entanglementStrength = parseFloat(document.getElementById('entanglementStrength').value);
                createQuantumEntanglement();
            }
            
            // åˆ›å»ºå…³ç³»é‡å¡‘è¿‡ç¨‹
            function createRelationshipReshaping() {
                // æ¸…é™¤ç°æœ‰çš„å…³ç³»é‡å¡‘
                reshapingNodes.forEach(node => scene.remove(node));
                reshapingConnections.forEach(conn => scene.remove(conn));
                reshapingNodes.length = 0;
                reshapingConnections.length = 0;
                
                // åˆ›å»ºå…³ç³»é‡å¡‘èŠ‚ç‚¹
                for (let i = 0; i < 12; i++) {
                    const node = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4, 16, 16),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ffff, 
                            shininess: 100,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    node.position.set(
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50
                    );
                    node.userData = { 
                        originalPosition: node.position.clone(),
                        reshapingPhase: Math.random() * Math.PI * 2,
                        connectionStrength: Math.random()
                    };
                    scene.add(node);
                    reshapingNodes.push(node);
                }
                
                // åˆ›å»ºåŠ¨æ€è¿æ¥
                for (let i = 0; i < reshapingNodes.length; i++) {
                    for (let j = i + 1; j < reshapingNodes.length; j++) {
                        if (Math.random() < 0.4) { // 40%æ¦‚ç‡è¿æ¥
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                reshapingNodes[i].position,
                                reshapingNodes[j].position
                            ]);
                            const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                                color: 0x00ffff, 
                                transparent: true, 
                                opacity: 0.5 
                            }));
                            scene.add(connection);
                            reshapingConnections.push(connection);
                        }
                    }
                }
                
                reshapingActive = true;
                document.getElementById('info').textContent = 'å…³ç³»é‡å¡‘è¿‡ç¨‹å¯åŠ¨ï¼';
            }
            
            function updateRelationshipReshaping() {
                reshapingSpeed = parseFloat(document.getElementById('reshapingSpeed').value);
                reshapingIntensity = parseFloat(document.getElementById('reshapingIntensity').value);
            }
            
            // åˆ›å»ºå®‡å®™æ¢æµ‹å™¨
            function createUniverseDetector() {
                // æ¸…é™¤ç°æœ‰çš„æ¢æµ‹å™¨
                detector.forEach(d => scene.remove(d));
                scanBeams.forEach(beam => scene.remove(beam));
                dataParticles.forEach(particle => scene.remove(particle));
                detector.length = 0;
                scanBeams.length = 0;
                dataParticles.length = 0;
                
                // åˆ›å»ºæ¢æµ‹å™¨ä¸»ä½“
                const detectorBody = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2, 2),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xffffff, 
                        shininess: 100,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                detectorBody.position.set(0, 0, 0);
                scene.add(detectorBody);
                detector.push(detectorBody);
                
                // åˆ›å»ºæ‰«æå…‰æŸ
                for (let i = 0; i < 8; i++) {
                    const beam = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, scanRange, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00, 
                            transparent: true, 
                            opacity: 0.6 
                        })
                    );
                    beam.position.set(0, 0, 0);
                    beam.rotation.x = Math.PI / 2;
                    beam.rotation.z = (i / 8) * Math.PI * 2;
                    beam.userData = { 
                        angle: (i / 8) * Math.PI * 2,
                        speed: Math.random() * 0.5 + 0.5
                    };
                    scene.add(beam);
                    scanBeams.push(beam);
                }
                
                // åˆ›å»ºæ•°æ®ç²’å­
                for (let i = 0; i < 15; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    particle.position.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    particle.userData = { 
                        targetPosition: particle.position.clone(),
                        scanPhase: Math.random() * Math.PI * 2
                    };
                    scene.add(particle);
                    dataParticles.push(particle);
                }
                
                detectorActive = true;
                document.getElementById('info').textContent = 'å®‡å®™æ¢æµ‹å™¨å¯åŠ¨ï¼å¼€å§‹æ‰«æï¼';
            }
            
            function updateUniverseDetector() {
                detectorSpeed = parseFloat(document.getElementById('detectorSpeed').value);
                scanRange = parseFloat(document.getElementById('scanRange').value);
            }
            
            // é‡ç½®è§†è§’
            function resetView() {
                // é‡ç½®æ‰€æœ‰è§†è§’å‚æ•°
                mouseWheelZoom = 80;
                mouseRotationX = 0;
                mouseRotationY = 0;
                rotationAngle = 0;
                zoomLevel = 80;
                sphereAngleX = 0;
                sphereAngleY = 0;
                sphereRadius = 100;
                
                // é‡ç½®åˆ°æ­£é¢è§†è§’
                setView('front');
                camera.position.set(0, 0, 80);
                camera.lookAt(0, 0, 0);
                
                document.getElementById('info').textContent = 'è§†è§’å·²é‡ç½®åˆ°æ­£é¢è§†è§’';
            }
            
            // åˆ‡æ¢æ§åˆ¶é¢æ¿æ˜¾ç¤º/éšè—
            function toggleControls() {
                const controls = document.getElementById('controls');
                const toggleButton = document.querySelector('#instructions button');
                
                if (controls.style.display === 'none') {
                    controls.style.display = 'block';
                    toggleButton.textContent = 'éšè—æ§åˆ¶é¢æ¿';
                } else {
                    controls.style.display = 'none';
                    toggleButton.textContent = 'æ˜¾ç¤ºæ§åˆ¶é¢æ¿';
                }
            }
            
            // åˆ‡æ¢ä½¿ç”¨è¯´æ˜é¢æ¿æ˜¾ç¤º/éšè—
            function toggleInstructions() {
                const instructions = document.getElementById('instructions');
                const toggleButton = document.querySelector('#instructions button:nth-last-child(2)');
                
                if (instructions.style.display === 'none') {
                    instructions.style.display = 'block';
                    toggleButton.textContent = 'éšè—è¯´æ˜';
                } else {
                    instructions.style.display = 'none';
                    toggleButton.textContent = 'æ˜¾ç¤ºè¯´æ˜';
                }
            }
            
            // åˆ‡æ¢è¯¦ç»†è¯´æ˜é¢æ¿æ˜¾ç¤º/éšè—
            function toggleDetailedGuide() {
                const detailedGuide = document.getElementById('detailedGuide');
                const toggleButton = document.querySelector('#instructions button:last-child');
                
                if (detailedGuide.style.display === 'none') {
                    detailedGuide.style.display = 'block';
                    toggleButton.textContent = 'å…³é—­è¯´æ˜';
                } else {
                    detailedGuide.style.display = 'none';
                    toggleButton.textContent = 'è¯¦ç»†è¯´æ˜';
                }
            }
            
            // æ›´æ–°èŠ‚ç‚¹æ•°é‡
            function updateNodeCount() {
                targetNodeCount = parseInt(document.getElementById('nodeCount').value);
                document.getElementById('info').textContent = `ç›®æ ‡èŠ‚ç‚¹æ•°é‡: ${targetNodeCount}`;
                updatePerformanceHint();
            }
            
            // æ›´æ–°æ€§èƒ½æç¤º
            function updatePerformanceHint() {
                const performanceDiv = document.getElementById('performance');
                if (targetNodeCount <= 500) {
                    performanceDiv.textContent = `æ€§èƒ½æç¤ºï¼šèŠ‚ç‚¹æ•°é‡ ${targetNodeCount}ï¼Œæ€§èƒ½ä¼˜ç§€`;
                    performanceDiv.style.color = '#00ff00';
                } else if (targetNodeCount <= 2000) {
                    performanceDiv.textContent = `æ€§èƒ½æç¤ºï¼šèŠ‚ç‚¹æ•°é‡ ${targetNodeCount}ï¼Œæ€§èƒ½è‰¯å¥½`;
                    performanceDiv.style.color = '#ffff00';
                } else if (targetNodeCount <= 3500) {
                    performanceDiv.textContent = `æ€§èƒ½æç¤ºï¼šèŠ‚ç‚¹æ•°é‡ ${targetNodeCount}ï¼Œæ€§èƒ½ä¸€èˆ¬`;
                    performanceDiv.style.color = '#ff8800';
                } else {
                    performanceDiv.textContent = `æ€§èƒ½æç¤ºï¼šèŠ‚ç‚¹æ•°é‡ ${targetNodeCount}ï¼Œæ€§èƒ½è¾ƒå·®ï¼Œå»ºè®®é™ä½`;
                    performanceDiv.style.color = '#ff0000';
                }
            }
            
            // é‡æ–°ç”Ÿæˆç½‘ç»œ
            function regenerateNetwork() {
                // æ¸…é™¤ç°æœ‰ç½‘ç»œ
                motherNodes.forEach(node => scene.remove(node));
                motherEdges.forEach(({ edge }) => scene.remove(edge));
                motherNodes.length = 0;
                motherEdges.length = 0;
                
                // æ¸…é™¤å­å®‡å®™
                subNodes.forEach(node => scene.remove(node));
                subEdges.forEach(({ edge }) => scene.remove(edge));
                subNodes.length = 0;
                subEdges.length = 0;
                subUniverseGenerated = false;
                
                // æ¸…é™¤å­æ¯å®‡å®™è¿æ¥
                universeConnections.forEach(({ edge }) => scene.remove(edge));
                universeConnections.length = 0;
                
                // é‡æ–°ç”Ÿæˆæ¯å®‡å®™
                nodeCount = targetNodeCount;
                generateMotherUniverse();
                
                document.getElementById('info').textContent = `ç½‘ç»œé‡æ–°ç”Ÿæˆå®Œæˆï¼èŠ‚ç‚¹æ•°é‡: ${nodeCount}`;
                updatePerformanceHint();
            }
            
            // ç”Ÿæˆæ¯å®‡å®™ï¼ˆé‡æ„ä¸ºç‹¬ç«‹å‡½æ•°ï¼‰
            function generateMotherUniverse() {
                // åˆ›å»ºæ¯å®‡å®™èŠ‚ç‚¹
                const motherGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const motherMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, shininess: 100 });
                
                for (let i = 0; i < nodeCount; i++) {
                    const node = new THREE.Mesh(motherGeometry, motherMaterial.clone());
                    node.position.set(
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40
                    );
                    scene.add(node);
                    motherNodes.push(node);
                    motherMaterials.push(node.material);
                }
                
                // åˆ›å»ºæ¯å®‡å®™è¿æ¥ï¼ˆåŠ¨æ€è°ƒæ•´è¿æ¥æ¦‚ç‡ä»¥ä¿æŒæ€§èƒ½ï¼‰
                let edgeCount = 0;
                const maxEdges = Math.min(5000, nodeCount * 2); // æœ€å¤§è¾¹æ•°é™åˆ¶
                const connectionProbability = Math.min(0.02, 10000 / (nodeCount * nodeCount)); // åŠ¨æ€è¿æ¥æ¦‚ç‡
                
                for (let i = 0; i < nodeCount && edgeCount < maxEdges; i++) {
                    for (let j = i + 1; j < nodeCount && edgeCount < maxEdges; j++) {
                        if (Math.random() < connectionProbability) {
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                motherNodes[i].position,
                                motherNodes[j].position
                            ]);
                            const edge = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 }));
                            scene.add(edge);
                            motherEdges.push({ edge, startIdx: i, endIdx: j });
                            edgeCount++;
                        }
                    }
                }
            }

            // åŠ¨ç”»å¾ªç¯
            function animate() {
                requestAnimationFrame(animate);

                // æ¯å®‡å®™å‹ç¼©
                motherNodes.forEach(node => {
                    node.position.multiplyScalar(motherCompressFactor);
                });
                motherEdges.forEach(({ edge, startIdx, endIdx }) => {
                    const positions = edge.geometry.attributes.position.array;
                    positions[0] = motherNodes[startIdx].position.x;
                    positions[1] = motherNodes[startIdx].position.y;
                    positions[2] = motherNodes[startIdx].position.z;
                    positions[3] = motherNodes[endIdx].position.x;
                    positions[4] = motherNodes[endIdx].position.y;
                    positions[5] = motherNodes[endIdx].position.z;
                    edge.geometry.attributes.position.needsUpdate = true;
                });

                // å­æ¯å®‡å®™è¿æ¥é—ªçƒ
                universeConnections.forEach(({ edge, motherIdx, subIdx }) => {
                    const positions = edge.geometry.attributes.position.array;
                    positions[0] = motherNodes[motherIdx].position.x;
                    positions[1] = motherNodes[motherIdx].position.y;
                    positions[2] = motherNodes[motherIdx].position.z;
                    positions[3] = subNodes[subIdx].position.x;
                    positions[4] = subNodes[subIdx].position.y;
                    positions[5] = subNodes[subIdx].position.z;
                    edge.geometry.attributes.position.needsUpdate = true;
                    edge.material.opacity = 0.7 + Math.sin(Date.now() * 0.002) * 0.2;
                });

                // ç›¸ä½æ³¢ä¼ æ’­
                updatePhaseWave(motherNodes, motherMaterials);
                if (subUniverseGenerated) updatePhaseWave(subNodes, subMaterials);

                // ç²’å­äº¤äº’
                if (showParticles) updateParticleInteraction();

                // è¾¹ç•Œå¢™é¢œè‰²ä¸æŒ¯åŠ¨
                boundaryStrength = Math.max(0, boundaryStrength - 0.003);
                boundaryMaterial.color.setHSL(boundaryStrength % 1, 1, 0.5);
                boundaryMaterial.opacity = Math.min(0.9, 0.3 + boundaryStrength);
                boundaryWall.position.set(0, 0, Math.sin(Date.now() * 0.005) * 0.5);

                // å†²ç ´ç«èŠ±æ›´æ–°
                sparks.forEach((spark, i) => {
                    spark.position.add(spark.velocity);
                    if (spark.position.length() > 35) {
                        scene.remove(spark);
                        sparks.splice(i, 1);
                    }
                });

                // å¼ºå¤§å­˜åœ¨åŠ¨ç”»
                powerfulBeings.forEach((being, i) => {
                    being.rotation.y += 0.01;
                    being.rotation.x += 0.005;
                    powerfulInfluences[i].rotation.y += 0.005;
                    powerfulInfluences[i].material.opacity = 0.1 + Math.sin(Date.now() * 0.001 + i) * 0.05;
                });

                // èƒ½çº§ç€‘å¸ƒåŠ¨ç”»
                if (energyWaterfallActive) {
                    energyParticles.forEach((particle, i) => {
                        const userData = particle.userData;
                        userData.angle += waterfallSpeed * 0.01;
                        particle.position.x = Math.cos(userData.angle) * userData.radius;
                        particle.position.z = Math.sin(userData.angle) * userData.radius;
                        particle.position.y += Math.sin(Date.now() * 0.001 + i) * 0.02;
                    });
                }

                // å“¥ç™½å°¼é—­ç¯åŠ¨ç”»
                if (copernicusLoopActive) {
                    copernicusNodes.forEach((node, i) => {
                        node.rotation.y += loopSpeed * 0.01;
                        node.material.opacity = 0.8 + Math.sin(Date.now() * 0.002 + i) * 0.2;
                    });
                }

                // æ„è¯†è§‰é†’åŠ¨ç”»
                if (consciousnessActive) {
                    consciousnessNodes.forEach((node, i) => {
                        node.userData.awakeningLevel += awakeningSpeed * 0.01;
                        node.material.opacity = 0.8 + Math.sin(node.userData.awakeningLevel) * 0.2;
                        node.rotation.y += awakeningSpeed * 0.005;
                        node.position.y += Math.sin(Date.now() * 0.001 + i) * 0.01;
                    });
                }
                
                // æ—¶é—´ç®­å¤´åŠ¨ç”»
                if (timeArrowActive) {
                    timeArrow.forEach(arrow => {
                        arrow.rotation.y += timeArrowSpeed * 0.01;
                        arrow.material.opacity = 0.8 + Math.sin(Date.now() * 0.002) * 0.2;
                    });
                    entropyParticles.forEach((particle, i) => {
                        particle.position.z += particle.userData.speed * timeArrowSpeed * 0.1;
                        particle.userData.entropy += entropyRate * 0.01;
                        particle.material.opacity = 0.6 + Math.sin(particle.userData.entropy) * 0.3;
                        if (particle.position.z > 40) {
                            particle.position.z = -40;
                        }
                    });
                }
                
                // é‡å­çº ç¼ åŠ¨ç”»
                if (entanglementActive) {
                    entanglementPairs.forEach((pair, i) => {
                        pair.particle1.userData.phase += entanglementStrength * 0.02;
                        pair.particle2.userData.phase += entanglementStrength * 0.02;
                        
                        // çº ç¼ ç²’å­åŒæ­¥è¿åŠ¨
                        const phase1 = pair.particle1.userData.phase;
                        const phase2 = pair.particle2.userData.phase;
                        
                        pair.particle1.position.x += Math.sin(phase1) * 0.01;
                        pair.particle1.position.y += Math.cos(phase1) * 0.01;
                        pair.particle2.position.x += Math.sin(phase2 + Math.PI) * 0.01;
                        pair.particle2.position.y += Math.cos(phase2 + Math.PI) * 0.01;
                        
                        // æ›´æ–°è¿æ¥çº¿
                        const connection = entanglementConnections[i];
                        if (connection) {
                            const positions = connection.geometry.attributes.position.array;
                            positions[0] = pair.particle1.position.x;
                            positions[1] = pair.particle1.position.y;
                            positions[2] = pair.particle1.position.z;
                            positions[3] = pair.particle2.position.x;
                            positions[4] = pair.particle2.position.y;
                            positions[5] = pair.particle2.position.z;
                            connection.geometry.attributes.position.needsUpdate = true;
                        }
                    });
                }
                
                // å…³ç³»é‡å¡‘åŠ¨ç”»
                if (reshapingActive) {
                    reshapingNodes.forEach((node, i) => {
                        node.userData.reshapingPhase += reshapingSpeed * 0.02;
                        const phase = node.userData.reshapingPhase;
                        
                        // èŠ‚ç‚¹ä½ç½®é‡å¡‘
                        const offset = new THREE.Vector3(
                            Math.sin(phase) * reshapingIntensity * 2,
                            Math.cos(phase * 1.3) * reshapingIntensity * 2,
                            Math.sin(phase * 0.7) * reshapingIntensity * 2
                        );
                        node.position.copy(node.userData.originalPosition).add(offset);
                        
                        // è¿æ¥å¼ºåº¦å˜åŒ–
                        node.userData.connectionStrength = 0.5 + Math.sin(phase) * 0.5;
                        node.material.opacity = 0.8 + Math.sin(phase) * 0.2;
                    });
                }
                
                // å®‡å®™æ¢æµ‹å™¨åŠ¨ç”»
                if (detectorActive) {
                    detector.forEach(d => {
                        d.rotation.y += detectorSpeed * 0.01;
                        d.rotation.x += detectorSpeed * 0.005;
                    });
                    
                    scanBeams.forEach((beam, i) => {
                        beam.userData.angle += detectorSpeed * 0.02;
                        beam.rotation.z = beam.userData.angle;
                        beam.material.opacity = 0.6 + Math.sin(Date.now() * 0.003 + i) * 0.3;
                    });
                    
                    dataParticles.forEach((particle, i) => {
                        particle.userData.scanPhase += detectorSpeed * 0.01;
                        const phase = particle.userData.scanPhase;
                        
                        // æ•°æ®ç²’å­å‘æ¢æµ‹å™¨ç§»åŠ¨
                        const direction = new THREE.Vector3().subVectors(
                            new THREE.Vector3(0, 0, 0), 
                            particle.position
                        ).normalize();
                        particle.position.add(direction.multiplyScalar(0.1));
                        
                        // æ‰«ææ•ˆæœ
                        particle.material.opacity = 0.8 + Math.sin(phase) * 0.2;
                        particle.rotation.y += detectorSpeed * 0.01;
                    });
                }

                // è§†è§’åˆ‡æ¢
                if (viewMode === 'front') {
                    camera.position.set(0, 0, 80);
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                } else if (viewMode === 'side') {
                    camera.position.set(80, 0, 0);
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                } else if (viewMode === 'rotate') {
                    rotationAngle += 0.0015;
                    camera.position.x = 80 * Math.sin(rotationAngle);
                    camera.position.z = 80 * Math.cos(rotationAngle);
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                } else if (viewMode === 'zoom') {
                    zoomLevel += Math.sin(Date.now() * 0.0004) * 1;
                    camera.position.z = Math.max(10, Math.min(500, zoomLevel));
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                } else if (viewMode === 'rotateZoom') {
                    rotationAngle += 0.0015;
                    zoomLevel += Math.sin(Date.now() * 0.0004) * 1;
                    camera.position.x = Math.max(10, Math.min(500, zoomLevel)) * Math.sin(rotationAngle);
                    camera.position.z = Math.max(10, Math.min(500, zoomLevel)) * Math.cos(rotationAngle);
                    camera.position.y = Math.sin(Date.now() * 0.0004) * 10;
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                } else if (viewMode === 'manual') {
                    rotationAngle += manualRotationSpeed;
                    camera.position.x = manualZoom * Math.sin(rotationAngle);
                    camera.position.z = manualZoom * Math.cos(rotationAngle);
                    camera.position.y = Math.sin(Date.now() * 0.0004) * 10;
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                    console.log(`ç›¸æœºä½ç½®: x=${camera.position.x.toFixed(2)}, z=${camera.position.z.toFixed(2)}`);
                } else if (viewMode === 'sphere360') {
                    // 360åº¦çƒä½“æ»šåŠ¨è§†è§’
                    sphereAngleX += sphereSpeed;
                    sphereAngleY += sphereSpeed * 0.7; // Yè½´æ»šåŠ¨ç¨æ…¢ï¼Œåˆ›é€ æ›´è‡ªç„¶çš„çƒä½“è¿åŠ¨
                    
                    // çƒé¢åæ ‡è®¡ç®—
                    const x = sphereRadius * Math.sin(sphereAngleY) * Math.cos(sphereAngleX);
                    const y = sphereRadius * Math.cos(sphereAngleY);
                    const z = sphereRadius * Math.sin(sphereAngleY) * Math.sin(sphereAngleX);
                    
                    camera.position.set(x, y, z);
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                    
                    // æ·»åŠ è½»å¾®çš„ä¸Šä¸‹æµ®åŠ¨ï¼Œæ¨¡æ‹Ÿçƒä½“æ»šåŠ¨
                    camera.position.y += Math.sin(Date.now() * 0.0003) * 5;
                } else if (viewMode === 'free') {
                    // è‡ªç”±è§†è§’ï¼šé¼ æ ‡æ§åˆ¶ï¼Œä¸è‡ªåŠ¨æ›´æ–°ç›¸æœºä½ç½®
                    // ç›¸æœºä½ç½®ç”±é¼ æ ‡äº‹ä»¶æ§åˆ¶
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                }

                renderer.render(scene, camera);
            }
            animate();

            // é¼ æ ‡æ»šè½®ç¼©æ”¾
            let mouseWheelZoom = 80;
            const minZoom = 10;
            const maxZoom = 500;
            
            // é¼ æ ‡æ‹–æ‹½æ—‹è½¬
            let isMouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let mouseRotationX = 0;
            let mouseRotationY = 0;
            
            window.addEventListener('wheel', (event) => {
                event.preventDefault();
                
                // æ ¹æ®æ»šè½®æ–¹å‘è°ƒæ•´ç¼©æ”¾
                if (event.deltaY < 0) {
                    mouseWheelZoom = Math.max(minZoom, mouseWheelZoom - 5);
                } else {
                    mouseWheelZoom = Math.min(maxZoom, mouseWheelZoom + 5);
                }
                
                // æ›´æ–°ç›¸æœºä½ç½®
                if (viewMode === 'front' || viewMode === 'side') {
                    camera.position.z = mouseWheelZoom;
                } else if (viewMode === 'rotate' || viewMode === 'rotateZoom') {
                    camera.position.x = mouseWheelZoom * Math.sin(rotationAngle);
                    camera.position.z = mouseWheelZoom * Math.cos(rotationAngle);
                } else if (viewMode === 'zoom') {
                    camera.position.z = mouseWheelZoom;
                } else if (viewMode === 'manual') {
                    camera.position.x = mouseWheelZoom * Math.sin(rotationAngle);
                    camera.position.z = mouseWheelZoom * Math.cos(rotationAngle);
                } else if (viewMode === 'sphere360') {
                    sphereRadius = mouseWheelZoom;
                } else if (viewMode === 'free') {
                    // è‡ªç”±è§†è§’ï¼šæ›´æ–°ç›¸æœºä½ç½®
                    const radius = mouseWheelZoom;
                    camera.position.x = radius * Math.sin(mouseRotationY) * Math.cos(mouseRotationX);
                    camera.position.y = radius * Math.sin(mouseRotationX);
                    camera.position.z = radius * Math.cos(mouseRotationY) * Math.cos(mouseRotationX);
                }
                
                // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
                document.getElementById('info').textContent = `é¼ æ ‡æ»šè½®ç¼©æ”¾: ${mouseWheelZoom.toFixed(0)}`;
            });
            
            // é¼ æ ‡æ‹–æ‹½æ—‹è½¬äº‹ä»¶
            window.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            window.addEventListener('mousemove', (event) => {
                if (isMouseDown && viewMode === 'free') {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    mouseRotationX += deltaY * 0.01;
                    mouseRotationY += deltaX * 0.01;
                    
                    // é™åˆ¶å‚ç›´æ—‹è½¬è§’åº¦
                    mouseRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseRotationX));
                    
                    // æ›´æ–°ç›¸æœºä½ç½®
                    const radius = mouseWheelZoom;
                    camera.position.x = radius * Math.sin(mouseRotationY) * Math.cos(mouseRotationX);
                    camera.position.y = radius * Math.sin(mouseRotationX);
                    camera.position.z = radius * Math.cos(mouseRotationY) * Math.cos(mouseRotationX);
                    
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                    
                    // æ›´æ–°ä¿¡æ¯æ˜¾ç¤º
                    document.getElementById('info').textContent = `è‡ªç”±è§†è§’: æ—‹è½¬X=${(mouseRotationX * 180 / Math.PI).toFixed(1)}Â°, Y=${(mouseRotationY * 180 / Math.PI).toFixed(1)}Â°, ç¼©æ”¾=${mouseWheelZoom.toFixed(0)}`;
                }
            });

            // é”®ç›˜å¿«æ·é”®
            window.addEventListener('keydown', (event) => {
                if (event.key === 'h' || event.key === 'H') {
                    // Hé”®ï¼šéšè—/æ˜¾ç¤ºæ§åˆ¶é¢æ¿
                    toggleControls();
                } else if (event.key === 'i' || event.key === 'I') {
                    // Ié”®ï¼šéšè—/æ˜¾ç¤ºä½¿ç”¨è¯´æ˜
                    toggleInstructions();
                } else if (event.key === 'g' || event.key === 'G') {
                    // Gé”®ï¼šéšè—/æ˜¾ç¤ºè¯¦ç»†è¯´æ˜
                    toggleDetailedGuide();
                } else if (event.key === 'r' || event.key === 'R') {
                    // Ré”®ï¼šé‡ç½®è§†è§’
                    resetView();
                }
            });

            // çª—å£è‡ªé€‚åº”
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // åˆå§‹åŒ–ç”Ÿæˆæ¯å®‡å®™
            generateMotherUniverse();
            updatePerformanceHint();
            
            console.log("åœºæ™¯åŠ è½½å®Œæˆï¼");
        } catch (error) {
            console.error("åŠ è½½å¤±è´¥ï¼š", error);
            document.getElementById('info').textContent = "åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°ï¼";
        }
    </script>
</body>
</html>
