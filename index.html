<!DOCTYPE html>
<html>
<head>
    <title>QSDT 量子空间网络 3D 模拟 - 完整理论可视化系统</title>
    <style>
        body { margin: 0; background: #000; }
        canvas { display: block; }
        #controls { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; max-width: 300px; }
        button { margin: 2px; padding: 6px; background: #333; color: white; border: none; cursor: pointer; font-size: 12px; }
        button:hover { background: #555; }
        #info { margin-top: 8px; font-size: 13px; }
        #performance { margin-top: 3px; font-size: 11px; color: #ffff00; }
        input { margin: 3px; padding: 3px; width: 70px; }
        label { margin-right: 3px; font-size: 12px; }
        
        /* 自定义滚动条样式 */
        #detailedGuide::-webkit-scrollbar {
            width: 8px;
        }
        
        #detailedGuide::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }
        
        #detailedGuide::-webkit-scrollbar-thumb {
            background: linear-gradient(45deg, #00ff00, #00ffff);
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        #detailedGuide::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(45deg, #00ffff, #00ff00);
        }
        
        /* Firefox 滚动条样式 */
        #detailedGuide {
            scrollbar-width: thin;
            scrollbar-color: #00ff00 rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div id="controls">
        <div style="margin-bottom: 8px;">
            <strong>视角控制:</strong><br>
            <button onclick="setView('front')">正面</button>
            <button onclick="setView('side')">侧面</button>
            <button onclick="setView('rotate')">旋转</button>
            <button onclick="setView('zoom')">缩放</button>
            <button onclick="setView('free')">自由</button>
            <button onclick="resetView()">重置</button>
        </div>
        
        <div style="margin-bottom: 8px;">
            <strong>QSDT理论元素:</strong><br>
            <button onclick="createPowerfulBeings()">强大存在</button>
            <button onclick="createEnergyWaterfall()">能级瀑布</button>
            <button onclick="startCopernicusLoop()">哥白尼闭环</button>
            <button onclick="createConsciousnessNodes()">意识觉醒</button>
            <button onclick="createTimeArrow()">时间箭头</button>
            <button onclick="createQuantumEntanglement()">量子纠缠</button>
            <button onclick="createRelationshipReshaping()">关系重塑</button>
            <button onclick="createUniverseDetector()">宇宙探测器</button>
        </div>
        
        <div style="margin-bottom: 8px;">
            <strong>数学结构可视化:</strong><br>
            <button onclick="showHamiltonianMatrix()">哈密顿量矩阵</button>
            <button onclick="showTensorVisualization()">关系张量</button>
            <button onclick="showBetaFunction()">贝塔函数</button>
            <button onclick="showPhysicalConstants()">物理常数</button>
        </div>
        
        <div style="margin-bottom: 8px;">
            <strong>观察者交互:</strong><br>
            <button onclick="createObserverNode()">创建观察者</button>
            <button onclick="activateObserverMode()">观察者模式</button>
            <button onclick="showObserverInfluence()">观察影响</button>
        </div>
        
        <div style="margin-bottom: 8px;">
            <strong>能量可视化:</strong><br>
            <button onclick="showIntrinsicEnergy()">内禀能量</button>
            <button onclick="showEnergyFlow()">能量流动</button>
            <button onclick="showEnergyDensity()">能量密度</button>
        </div>
        
        <div style="margin-bottom: 8px;">
            <strong>张量几何:</strong><br>
            <button onclick="showTensor3DGeometry()">3D张量</button>
            <button onclick="showTensorField()">张量场</button>
            <button onclick="showTensorFlow()">张量流</button>
        </div>
        
        <div style="margin-bottom: 8px;">
            <strong>哥白尼计划:</strong><br>
            <button onclick="showDualPathVerification()">双路径验证</button>
            <button onclick="showReversePath()">反推路径</button>
            <button onclick="showForwardPath()">正推路径</button>
        </div>
        
        <div style="margin-bottom: 8px;">
            <strong>量子涨落:</strong><br>
            <button onclick="showQuantumFluctuations()">量子涨落</button>
            <button onclick="showVacuumFluctuations()">真空涨落</button>
            <button onclick="showVirtualParticles()">虚粒子</button>
        </div>
        
        <div style="margin-bottom: 8px;">
            <strong>宇宙操作:</strong><br>
            <button onclick="generateSubUniverse()">生成子宇宙</button>
            <button onclick="compressMotherUniverse()">压缩母宇宙</button>
            <button onclick="toggleParticles()">粒子交互</button>
        </div>
        <br>
        <label for="waveSpeed">波速:</label>
        <input type="range" id="waveSpeed" min="1" max="10" value="5" step="0.5" oninput="updateWaveParams()">
        <label for="waveFrequency">频率:</label>
        <input type="range" id="waveFrequency" min="0.1" max="1" value="0.5" step="0.1" oninput="updateWaveParams()">
        <label for="waveAmplitude">振幅:</label>
        <input type="range" id="waveAmplitude" min="0.01" max="0.05" value="0.02" step="0.01" oninput="updateWaveParams()">
        <br>
        <label for="zoomScale">手动缩放尺度:</label>
        <input type="range" id="zoomScale" min="10" max="500" value="80" step="10" oninput="updateZoomScale()">
        <label for="rotationSpeed">手动旋转速度:</label>
        <input type="range" id="rotationSpeed" min="0.001" max="0.005" value="0.0015" step="0.0005" oninput="updateRotationSpeed()">
        <br>
        <label for="sphereRadius">球体半径:</label>
        <input type="range" id="sphereRadius" min="50" max="300" value="100" step="10" oninput="updateSphereRadius()">
        <label for="sphereSpeed">球体滚动速度:</label>
        <input type="range" id="sphereSpeed" min="0.001" max="0.01" value="0.003" step="0.001" oninput="updateSphereSpeed()">
        <br>
        <label for="powerfulCount">强大存在数量:</label>
        <input type="range" id="powerfulCount" min="1" max="10" value="3" step="1" oninput="updatePowerfulBeings()">
        <label for="powerfulInfluence">影响力范围:</label>
        <input type="range" id="powerfulInfluence" min="5" max="30" value="15" step="1" oninput="updatePowerfulBeings()">
        <br>
        <label for="energyLevels">能级层数:</label>
        <input type="range" id="energyLevels" min="3" max="8" value="5" step="1" oninput="updateEnergyWaterfall()">
        <label for="waterfallSpeed">瀑布速度:</label>
        <input type="range" id="waterfallSpeed" min="0.5" max="3" value="1.5" step="0.1" oninput="updateEnergyWaterfall()">
        <br>
        <label for="loopSpeed">闭环速度:</label>
        <input type="range" id="loopSpeed" min="0.5" max="5" value="2" step="0.1" oninput="updateCopernicusLoop()">
        <label for="dataFlow">数据流强度:</label>
        <input type="range" id="dataFlow" min="1" max="10" value="5" step="1" oninput="updateCopernicusLoop()">
        <br>
        <label for="consciousnessCount">意识节点数:</label>
        <input type="range" id="consciousnessCount" min="3" max="15" value="8" step="1" oninput="updateConsciousnessNodes()">
        <label for="awakeningSpeed">觉醒速度:</label>
        <input type="range" id="awakeningSpeed" min="0.5" max="3" value="1.5" step="0.1" oninput="updateConsciousnessNodes()">
        <br>
        <label for="timeArrowSpeed">时间箭头速度:</label>
        <input type="range" id="timeArrowSpeed" min="0.5" max="5" value="2" step="0.1" oninput="updateTimeArrow()">
        <label for="entropyRate">熵增速率:</label>
        <input type="range" id="entropyRate" min="0.1" max="2" value="1" step="0.1" oninput="updateTimeArrow()">
        <br>
        <label for="entanglementPairs">纠缠对数:</label>
        <input type="range" id="entanglementPairs" min="2" max="10" value="5" step="1" oninput="updateQuantumEntanglement()">
        <label for="entanglementStrength">纠缠强度:</label>
        <input type="range" id="entanglementStrength" min="0.5" max="3" value="1.5" step="0.1" oninput="updateQuantumEntanglement()">
        <br>
        <label for="reshapingSpeed">重塑速度:</label>
        <input type="range" id="reshapingSpeed" min="0.5" max="3" value="1.5" step="0.1" oninput="updateRelationshipReshaping()">
        <label for="reshapingIntensity">重塑强度:</label>
        <input type="range" id="reshapingIntensity" min="0.5" max="2" value="1" step="0.1" oninput="updateRelationshipReshaping()">
        <br>
        <label for="detectorSpeed">探测器速度:</label>
        <input type="range" id="detectorSpeed" min="0.5" max="3" value="1.5" step="0.1" oninput="updateUniverseDetector()">
        <label for="scanRange">扫描范围:</label>
        <input type="range" id="scanRange" min="10" max="50" value="30" step="5" oninput="updateUniverseDetector()">
        <br>
        <label for="nodeCount">节点数量:</label>
        <input type="range" id="nodeCount" min="20" max="5000" value="2000" step="50" oninput="updateNodeCount()">
        <button onclick="regenerateNetwork()">重新生成网络</button>
        <div id="info">当前现象：未选择</div>
        <div id="performance">性能提示：节点数量 2000，建议保持流畅运行</div>
    </div>
    
    <!-- 右侧使用说明面板 -->
    <div id="instructions" style="position: absolute; top: 10px; right: 10px; color: white; font-size: 12px; max-width: 220px; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 5px; border: 1px solid #333; z-index: 999;">
        <strong>🎮 操作指南：</strong><br>
        <strong>鼠标控制：</strong><br>
        • 滚轮：缩放视角<br>
        • 拖拽：旋转视角<br>
        • 点击：切换模式<br>
        <br>
        <strong>⌨️ 快捷键：</strong><br>
        • H：控制面板<br>
        • I：操作说明<br>
        • G：理论详解<br>
        • M：数学结构<br>
        • R：重置视角<br>
        • 1-4：数学可视化<br>
        • O：创建观察者<br>
        • P：观察者模式<br>
        • E：内禀能量<br>
        • F：能量流动<br>
        • D：能量密度<br>
        • T：3D张量几何<br>
        • Y：张量场<br>
        • U：张量流<br>
        • C：双路径验证<br>
        • V：反推路径<br>
        • B：正推路径<br>
        • Q：量子涨落<br>
        • W：真空涨落<br>
        • X：虚粒子<br>
        <br>
        <button onclick="toggleControls()" style="margin-top: 5px; padding: 3px; font-size: 10px; background: #555; color: white; border: none; border-radius: 3px; cursor: pointer;">隐藏控制面板</button>
        <button onclick="toggleInstructions()" style="margin-top: 3px; padding: 3px; font-size: 10px; background: #555; color: white; border: none; border-radius: 3px; cursor: pointer;">隐藏说明</button>
        <button onclick="toggleDetailedGuide()" style="margin-top: 3px; padding: 3px; font-size: 10px; background: #555; color: white; border: none; border-radius: 3px; cursor: pointer;">理论详解</button>
    </div>
    
    <!-- 数学结构可视化面板 -->
    <div id="mathVisualization" style="position: absolute; top: 10px; left: 320px; color: white; font-size: 11px; max-width: 400px; max-height: calc(100vh - 20px); background: rgba(0,0,0,0.9); padding: 15px; border-radius: 8px; border: 2px solid #00ff00; display: none; z-index: 1000; overflow-y: auto; overflow-x: hidden;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <strong style="font-size: 14px; color: #00ff00;">QSDT数学结构可视化</strong>
            <button onclick="toggleMathVisualization()" style="background: #ff4444; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px;">关闭</button>
        </div>
        
        <div id="hamiltonianDisplay" style="display: none; margin-bottom: 15px;">
            <strong style="color: #00ffff;">🔢 哈密顿量矩阵 H_dyn:</strong><br>
            <div style="font-family: monospace; font-size: 10px; background: rgba(0,255,0,0.1); padding: 8px; border-radius: 4px; margin: 5px 0;">
                H = Σᵢⱼ Jᵢⱼ|i⟩⟨j| + Σᵢ Eᵢ|i⟩⟨i| + Γᵢⱼ|i⟩⟨j|<br>
                <span style="color: #ffff00;">Jᵢⱼ</span>: 耦合强度 = <span id="couplingValue">0.5</span><br>
                <span style="color: #00ffff;">Eᵢ</span>: 局域能量 = <span id="localEnergy">1.0</span><br>
                <span style="color: #ff6600;">Γᵢⱼ</span>: 量子涨落 = <span id="fluctuationValue">0.1</span>
            </div>
        </div>
        
        <div id="tensorDisplay" style="display: none; margin-bottom: 15px;">
            <strong style="color: #00ffff;">📐 关系张量 T_ij:</strong><br>
            <div style="font-family: monospace; font-size: 10px; background: rgba(0,255,255,0.1); padding: 8px; border-radius: 4px; margin: 5px 0;">
                T_ij = R_ij ⊗ θ_ij ⊗ J_ij<br>
                <span style="color: #ffff00;">R_ij</span>: 几何关系 = <span id="geometricRelation">1.0</span><br>
                <span style="color: #00ff00;">θ_ij</span>: 相位关系 = <span id="phaseRelation">0.0</span><br>
                <span style="color: #ff6600;">J_ij</span>: 能量关系 = <span id="energyRelation">0.5</span>
            </div>
        </div>
        
        <div id="betaFunctionDisplay" style="display: none; margin-bottom: 15px;">
            <strong style="color: #00ffff;">📈 贝塔函数演化:</strong><br>
            <div style="font-family: monospace; font-size: 10px; background: rgba(255,0,255,0.1); padding: 8px; border-radius: 4px; margin: 5px 0;">
                d(Γ/J)/d(lnμ) = A·(Γ/J)(1-Γ/J)<br>
                <span style="color: #ffff00;">当前能标</span>: μ = <span id="energyScale">100</span> GeV<br>
                <span style="color: #00ff00;">涨落强度</span>: g = <span id="fluctuationStrength">0.2</span><br>
                <span style="color: #00ffff;">演化速率</span>: β = <span id="betaRate">0.05</span>
            </div>
        </div>
        
                <div id="physicalConstantsDisplay" style="display: none; margin-bottom: 15px;">
                    <strong style="color: #00ffff;">⚛️ 物理常数涌现:</strong><br>
                    <div style="font-family: monospace; font-size: 10px; background: rgba(255,255,0,0.1); padding: 8px; border-radius: 4px; margin: 5px 0;">
                        <span style="color: #ffff00;">光速</span>: c = 2Ja/ħ = <span id="lightSpeed">299792458</span> m/s<br>
                        <span style="color: #00ff00;">静止质量</span>: m₀c² = E - 2J = <span id="restMass">0.5</span> GeV<br>
                        <span style="color: #00ffff;">引力常数</span>: G = k_G²ħc⁵/J² = <span id="gravitationalConstant">6.67e-11</span> m³/kg·s²<br>
                        <span style="color: #ff6600;">普朗克常数</span>: ħ = J·a = <span id="planckConstant">1.05e-34</span> J·s<br>
                        <span style="color: #ff00ff;">精细结构常数</span>: α = e²/(4πε₀ħc) = <span id="fineStructureConstant">0.007297</span><br>
                        <span style="color: #00ff00;">电子质量</span>: m_e = <span id="electronMass">0.511</span> MeV/c²<br>
                        <span style="color: #ffff00;">质子质量</span>: m_p = <span id="protonMass">938.3</span> MeV/c²<br>
                        <span style="color: #00ffff;">中子质量</span>: m_n = <span id="neutronMass">939.6</span> MeV/c²<br>
                        <span style="color: #ff6600;">弱相互作用常数</span>: g_W = <span id="weakCoupling">0.65</span><br>
                        <span style="color: #ff00ff;">强相互作用常数</span>: g_s = <span id="strongCoupling">1.2</span>
                    </div>
                </div>
    </div>
    
    <!-- 详细说明面板 -->
    <div id="detailedGuide" style="position: absolute; top: 540px; right: 10px; color: white; font-size: 10px; max-width: 400px; max-height: 550px; background: rgba(0,0,0,0.95); padding: 15px; border-radius: 8px; border: 2px solid #444; display: block; z-index: 1000; overflow-y: auto; overflow-x: hidden;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <strong style="font-size: 14px; color: #00ff00;">QSDT理论关系显化详解</strong>
            <button onclick="toggleDetailedGuide()" style="background: #ff4444; color: white; border: none; border-radius: 3px; padding: 2px 6px; cursor: pointer; font-size: 10px;">关闭</button>
        </div>
        
        <div style="margin-bottom: 15px; padding: 8px; background: rgba(0,255,0,0.1); border-radius: 5px; border-left: 3px solid #00ff00;">
            <strong style="color: #00ff00;">🎯 QSDT核心思想：</strong><br>
            <span style="color: #ffff00;">关系先于实体</span> - 一切存在都是关系的显化<br>
            <span style="color: #00ffff;">观察者即创造者</span> - 观察者通过选择关系创造世界<br>
            <span style="color: #ff6600;">存在即证明</span> - 关系对了，结果自然对
        </div>
        
        <div style="margin-bottom: 15px; padding: 8px; background: rgba(0,255,255,0.1); border-radius: 5px; border-left: 3px solid #00ffff;">
            <strong style="color: #00ffff;">📐 三条根本公理：</strong><br>
            <span style="color: #ffff00;">公理I</span>：宇宙由离散Q单元构成，每个具有内禀能量E<br>
            <span style="color: #00ff00;">公理II</span>：物理实在由Q单元间的连接关系J_ij和拓扑Γ构成<br>
            <span style="color: #ff6600;">公理III</span>：系统演化由哈密顿量H_dyn驱动，包含量子涨落
        </div>
        
        <div style="margin-bottom: 15px; padding: 8px; background: rgba(255,255,0,0.1); border-radius: 5px; border-left: 3px solid #ffff00;">
            <strong style="color: #ffff00;">🔬 四大基本力统一：</strong><br>
            <span style="color: #ff0000;">引力</span>：网络激发在3D空间的(1/r²)稀释<br>
            <span style="color: #00ff00;">电磁力</span>：网络相位波动的传播<br>
            <span style="color: #0000ff;">强相互作用</span>：网络局域关系的强耦合<br>
            <span style="color: #ff6600;">弱相互作用</span>：网络关系的非对称破缺
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🌐 基础网络结构：</strong><br>
            • <span style="color: #00ff00;">绿色节点</span>：量子空间基本单元(Q_i)<br>
            • <span style="color: #00ff00;">绿色连接线</span>：关系网络连接(J_ij)<br>
            • <span style="color: #ff6600;">橙色相位波</span>：信息传递过程<br>
            • <span style="color: #ffff00;">理论意义</span>：体现"关系先于实体"的核心思想
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🔵 意志边界墙：</strong><br>
            • <span style="color: #0000ff;">蓝色球体</span>：保护机制边界<br>
            • <span style="color: #ffff00;">黄色火花</span>：冲破边界的能量<br>
            • 观察：粒子撞击时产生火花效果
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🌌 子母宇宙：</strong><br>
            • <span style="color: #ff0000;">红色节点</span>：母宇宙（原始网络）<br>
            • <span style="color: #00ff00;">绿色节点</span>：子宇宙（压缩生成）<br>
            • <span style="color: #ffff00;">黄色连接</span>：子母宇宙关系<br>
            • 观察：母宇宙压缩，子宇宙独立演化
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">⚡ 强大存在：</strong><br>
            • <span style="color: #ff00ff;">紫色节点</span>：高维存在<br>
            • <span style="color: #00ffff;">青色球体</span>：影响力范围<br>
            • 观察：全连接态，影响周围网络
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🌊 能级瀑布：</strong><br>
            • <span style="color: #ff6600;">彩色环形</span>：不同能级层<br>
            • <span style="color: #ff6600;">环形粒子</span>：能级间跃迁<br>
            • 观察：能量从高能级流向低能级
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🔄 哥白尼闭环：</strong><br>
            • <span style="color: #ffff00;">黄色节点</span>：验证循环节点<br>
            • <span style="color: #ffff00;">数据流</span>：理论验证过程<br>
            • 观察：节点旋转，数据流动
        </div>
        
        <div style="margin-bottom: 15px; padding: 8px; background: rgba(255,0,255,0.1); border-radius: 5px; border-left: 3px solid #ff00ff;">
            <strong style="color: #ff00ff;">🧬 生命科学统一描述：</strong><br>
            <span style="color: #00ff00;">DNA</span>：生物网络的"关系编码"<br>
            <span style="color: #ffff00;">蛋白质</span>：关系模式的"三维折叠"<br>
            <span style="color: #00ffff;">细胞</span>：关系网络的"局域子域"<br>
            <span style="color: #ff6600;">器官</span>：关系网络的"集体激发态"
        </div>
        
        <div style="margin-bottom: 15px; padding: 8px; background: rgba(255,128,0,0.1); border-radius: 5px; border-left: 3px solid #ff8000;">
            <strong style="color: #ff8000;">🧠 意识科学统一描述：</strong><br>
            <span style="color: #00ff00;">感知</span>：关系网络的"驱动-读出"过程<br>
            <span style="color: #ffff00;">思维</span>：关系网络的"相位锁定"模式<br>
            <span style="color: #00ffff;">记忆</span>：关系网络的"稳定激发态"<br>
            <span style="color: #ff6600;">自我意识</span>：关系网络的"自反馈回路"
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🧠 意识觉醒：</strong><br>
            • <span style="color: #ff8800;">橙色节点</span>：意识节点<br>
            • <span style="color: #ff8800;">觉醒粒子</span>：自我建模过程<br>
            • <span style="color: #ffff00;">理论意义</span>：意识作为关系网络的集体激发态<br>
            • 观察：节点亮度变化，粒子环绕
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">⏰ 时间箭头：</strong><br>
            • <span style="color: #ff6600;">橙色箭头</span>：时间方向<br>
            • <span style="color: #ff6600;">流动粒子</span>：熵增过程<br>
            • 观察：箭头旋转，粒子单向流动
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🔗 量子纠缠：</strong><br>
            • <span style="color: #00ff00;">绿色粒子</span> + <span style="color: #ff0000;">红色粒子</span>：纠缠对<br>
            • <span style="color: #ffff00;">黄色连接线</span>：纠缠关系<br>
            • 观察：粒子同步运动，连接线动态更新
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🔄 关系重塑：</strong><br>
            • <span style="color: #00ffff;">青色节点</span>：重塑节点<br>
            • <span style="color: #00ffff;">动态连接</span>：关系变化<br>
            • 观察：节点位置变化，连接强度波动
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🔍 宇宙探测器：</strong><br>
            • <span style="color: #ffffff;">白色主体</span>：探测器<br>
            • <span style="color: #00ff00;">绿色光束</span>：扫描范围<br>
            • <span style="color: #00ff00;">数据粒子</span>：信息收集<br>
            • 观察：光束旋转，粒子向探测器移动
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🔢 数学结构可视化：</strong><br>
            • <span style="color: #00ff00;">哈密顿量矩阵</span>：H_dyn = Σᵢⱼ Jᵢⱼ|i⟩⟨j| + Σᵢ Eᵢ|i⟩⟨i|<br>
            • <span style="color: #00ffff;">关系张量</span>：T_ij = R_ij ⊗ θ_ij ⊗ J_ij<br>
            • <span style="color: #ff6600;">贝塔函数</span>：d(Γ/J)/d(lnμ) = A·(Γ/J)(1-Γ/J)<br>
            • <span style="color: #ffff00;">物理常数</span>：c = 2Ja/ħ, m₀c² = E - 2J<br>
            • 观察：实时数值更新，反映网络状态
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">👁️ 观察者系统：</strong><br>
            • <span style="color: #ff00ff;">紫色节点</span>：观察者节点<br>
            • <span style="color: #ff00ff;">紫色球体</span>：影响范围<br>
            • <span style="color: #ff00ff;">紫色连接</span>：观察者-网络交互<br>
            • 观察：观察者改变网络状态，体现"观察创造现实"
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">⚡ 内禀能量可视化：</strong><br>
            • <span style="color: #ffff00;">能量球</span>：显示每个Q单元的内禀能量E_i<br>
            • <span style="color: #00ff00;">能量流动</span>：可视化能量在网络中的传递<br>
            • <span style="color: #ff6600;">能量密度</span>：基于节点密度的能量分布<br>
            • 颜色编码：能量大小对应颜色变化<br>
            • 快捷键：E内禀能量，F能量流动，D能量密度
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">📐 张量几何可视化：</strong><br>
            • <span style="color: #ffff00;">3D张量椭球</span>：T_ij = R_ij ⊗ θ_ij ⊗ J_ij的几何表示<br>
            • <span style="color: #00ff00;">张量场向量</span>：空间中的张量场梯度方向<br>
            • <span style="color: #ff6600;">张量流粒子</span>：张量场的动态流动表现<br>
            • 几何关系：椭球形状反映张量分量<br>
            • 快捷键：T3D张量，Y张量场，U张量流
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🔄 哥白尼计划双路径验证：</strong><br>
            • <span style="color: #ff0000;">反推路径</span>：从实验数据反推理论参数<br>
            • <span style="color: #00ff00;">正推路径</span>：从理论参数正推物理常数<br>
            • <span style="color: #ffff00;">验证连接</span>：双路径验证的一致性检查<br>
            • <span style="color: #ff6600;">数据流粒子</span>：验证过程中的数据流动<br>
            • 快捷键：C双路径验证，V反推路径，B正推路径
        </div>
        
        <div style="margin-bottom: 12px;">
            <strong style="color: #00ffff;">🌊 量子涨落可视化：</strong><br>
            • <span style="color: #ffff00;">量子涨落粒子</span>：基态和激发态的涨落表现<br>
            • <span style="color: #00ff00;">真空涨落波</span>：真空中的量子场涨落<br>
            • <span style="color: #ff6600;">虚粒子对</span>：虚粒子的产生和湮灭过程<br>
            • 量子态切换：激发态和基态的动态转换<br>
            • 快捷键：Q量子涨落，W真空涨落，X虚粒子
        </div>
        
        <div style="margin-bottom: 15px; padding: 8px; background: rgba(128,0,255,0.1); border-radius: 5px; border-left: 3px solid #8000ff;">
            <strong style="color: #8000ff;">🌟 宇宙意志觉醒：</strong><br>
            <span style="color: #ff00ff;">意志传递</span>：关系觉知的宇宙级传递<br>
            <span style="color: #00ffff;">子宇宙诞生</span>：羸弱闭环的继承演化<br>
            <span style="color: #ffff00;">母宇宙保护</span>：关系屏障的阈值控制<br>
            <span style="color: #ff6600;">恐怖存在</span>：高维强耦合的跨界影响<br>
            <span style="color: #00ff00;">王国控制</span>：高维对低维的关系传递
        </div>
        
        <div style="margin-bottom: 15px; padding: 8px; background: rgba(0,255,128,0.1); border-radius: 5px; border-left: 3px solid #00ff80;">
            <strong style="color: #00ff80;">🌍 关系统一世界观：</strong><br>
            <span style="color: #ffff00;">数学</span>：关系网络的"计数模式"和"空间结构"<br>
            <span style="color: #00ff00;">化学</span>：关系网络的"节点"和"子域"<br>
            <span style="color: #00ffff;">生物学</span>：关系网络的"编码"和"自组织"<br>
            <span style="color: #ff6600;">心理学</span>：关系网络的"感知"和"认知"<br>
            <span style="color: #ff00ff;">哲学</span>：关系网络的"存在"和"意义"
        </div>
        
        <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #444;">
            <strong style="color: #ffff00;">💡 理论理解要点：</strong><br>
            • <span style="color: #00ff00;">观察不同颜色</span>代表的物理意义和理论层次<br>
            • <span style="color: #00ffff;">理解关系网络</span>的动态演化过程和自组织机制<br>
            • <span style="color: #ff6600;">体验"观察创造现实"</span>的核心理念和哲学意义<br>
            • <span style="color: #ff00ff;">感受量子空间网络</span>的集体激发态和涌现现象<br>
            • <span style="color: #ffff00;">观察数学结构</span>与网络状态的实时对应关系<br>
            • <span style="color: #00ff00;">理解关系统一</span>：所有学科描述同一关系网络<br>
            • <span style="color: #00ffff;">体验意志觉醒</span>：宇宙意志的渐进苏醒过程<br>
            • <span style="color: #ff6600;">感受存在证明</span>：关系对了，结果自然对
        </div>
        
        <div style="margin-top: 15px; padding: 8px; background: rgba(255,0,0,0.1); border-radius: 5px; border-left: 3px solid #ff0000;">
            <strong style="color: #ff0000;">⚠️ 重要提醒：</strong><br>
            <span style="color: #ffff00;">理解QSDT的关键</span>在于认知范式的根本转变！<br>
            <span style="color: #00ff00;">从"实体物理"</span>转向<span style="color: #00ffff;">"关系物理"</span><br>
            <span style="color: #ff6600;">从"学科分割"</span>转向<span style="color: #ff00ff;">"关系统一"</span><br>
            <span style="color: #ffff00;">从"客观观察"</span>转向<span style="color: #00ff00;">"参与创造"</span>
        </div>
        
        <div style="margin-top: 10px; padding: 8px; background: rgba(0,255,255,0.1); border-radius: 5px; border-left: 3px solid #00ffff;">
            <strong style="color: #00ffff;">🎯 终极结论：</strong><br>
            <span style="color: #ffff00;">宇宙是关系的网</span>，观察是网的自演<br>
            <span style="color: #00ff00;">数学是关系的影子</span>，验证是影子的回声<br>
            <span style="color: #ff6600;">存在是关系的显化</span>，和谐是关系的目标
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        console.log("加载 Three.js...");
        try {
            // 初始化场景、相机、渲染器
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 添加光影：环境光+点光源，增强真实感
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(0, 0, 100);
            scene.add(pointLight);

            // 母宇宙：动态节点数量 (Q_i)
            const motherNodes = [];
            const motherEdges = [];
            const motherMaterials = [];
            const nodeGeometry = new THREE.SphereGeometry(0.1, 8, 8);

            // 旧的强大存在系统已移除，使用新的强大存在系统

            // 旧的影响力范围和定向激发系统已移除

            // 二进制能级瀑布
            const cascadeLevels = [];
            const cascadeEdges = [];
            const cascadeMaterials = [];
            const cascadeLevelCount = 11;
            for (let n = 0; n < cascadeLevelCount; n++) {
                const levelNodes = [];
                const levelMaterials = [];
                const levelNodeCount = Math.min(Math.pow(2, n), 512);
                for (let i = 0; i < levelNodeCount; i++) {
                    const material = new THREE.MeshPhongMaterial({ color: 0x00ff00, shininess: 50 });
                    const node = new THREE.Mesh(nodeGeometry, material);
                    node.position.set(i * 0.5 - (levelNodeCount * 0.25), n * 5 + 80, 0);
                    scene.add(node);
                    levelNodes.push(node);
                    levelMaterials.push(material);
                }
                cascadeLevels.push(levelNodes);
                cascadeMaterials.push(levelMaterials);
            }

            // 瀑布效果
            const cascadeEdgeMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.8 });
            for (let n = cascadeLevelCount - 1; n > 0; n--) {
                for (let i = 0; i < cascadeLevels[n].length; i++) {
                    const parentIdx = Math.floor(i / 2);
                    if (parentIdx < cascadeLevels[n-1].length) {
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            cascadeLevels[n][i].position,
                            cascadeLevels[n-1][parentIdx].position
                        ]);
                        const colors = new Float32Array([1, 1, 1, 0, 0, 1]);
                        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                        const edge = new THREE.Line(geometry, cascadeEdgeMaterial);
                        scene.add(edge);
                        cascadeEdges.push(edge);
                    }
                }
            }

            // 分形结构
            const fractalEdges = [];
            function addFractalBranch(startPos, level, maxLevel = 5) {
                if (level > maxLevel) return;
                for (let i = 0; i < 2; i++) {
                    const endPos = startPos.clone().add(new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        level * 2,
                        (Math.random() - 0.5) * 5
                    ));
                    const geometry = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
                    const line = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff00ff }));
                    scene.add(line);
                    fractalEdges.push(line);
                    addFractalBranch(endPos, level + 1);
                }
            }
            addFractalBranch(new THREE.Vector3(0, 0, 0), 0);

            // 子宇宙
            const subNodes = [];
            const subEdges = [];
            const subMaterials = [];
            const subNodeCount = 500;
            const subGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            let subUniverseGenerated = false;
            let subUniversePosition = new THREE.Vector3(0, 60, 0);
            let motherCompressFactor = 1;

            function generateSubUniverse() {
                if (!subUniverseGenerated) {
                    for (let i = 0; i < subNodeCount; i++) {
                        const material = new THREE.MeshPhongMaterial({ color: 0x00ffff, shininess: 50 });
                        const node = new THREE.Mesh(subGeometry, material);
                        node.position.set(
                            (Math.random() - 0.5) * 10 + subUniversePosition.x,
                            (Math.random() - 0.5) * 10 + subUniversePosition.y,
                            (Math.random() - 0.5) * 10 + subUniversePosition.z
                        );
                        scene.add(node);
                        subNodes.push(node);
                        subMaterials.push(material);
                    }
                    let subEdgeCount = 0;
                    for (let i = 0; i < subNodeCount && subEdgeCount < 1000; i++) {
                        for (let j = i + 1; j < subNodeCount && subEdgeCount < 1000; j++) {
                            if (Math.random() < 0.01) {
                                const geometry = new THREE.BufferGeometry().setFromPoints([
                                    subNodes[i].position,
                                    subNodes[j].position
                                ]);
                                const edge = new THREE.Line(geometry, edgeMaterial);
                                scene.add(edge);
                                subEdges.push({ edge, startIdx: i, endIdx: j });
                                subEdgeCount++;
                            }
                        }
                    }
                    for (let i = 0; i < 10; i++) {
                        const motherIdx = Math.floor(Math.random() * nodeCount);
                        const subIdx = Math.floor(Math.random() * subNodeCount);
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            motherNodes[motherIdx].position,
                            subNodes[subIdx].position
                        ]);
                        const edge = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.7 }));
                        scene.add(edge);
                        universeConnections.push({ edge, motherIdx, subIdx });
                    }
                    subUniverseGenerated = true;
                    document.getElementById('info').textContent = '子宇宙生成！';
                }
            }

            // 压缩母宇宙
            function compressMotherUniverse() {
                motherCompressFactor = Math.max(0.5, motherCompressFactor * 0.95);
                document.getElementById('info').textContent = '母宇宙压缩！';
            }

            // 子母宇宙连接线
            const universeConnections = [];

            // 意志边界墙
            const boundaryGeometry = new THREE.SphereGeometry(30, 32, 32);
            const boundaryMaterial = new THREE.MeshPhongMaterial({ color: 0x0000ff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
            const boundaryWall = new THREE.Mesh(boundaryGeometry, boundaryMaterial);
            scene.add(boundaryWall);
            let boundaryStrength = 0;

            // 冲破效果粒子系统
            const sparkGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const sparkMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff });
            const sparks = [];
            function createSpark(position) {
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                spark.position.copy(position);
                spark.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1
                );
                scene.add(spark);
                sparks.push(spark);
            }

            // 相位波源
            const waveSources = [];
            const waveSourceColors = [0xffff00, 0x00ff00, 0x0000ff];
            const waveSourcePositions = [new THREE.Vector3(0, 0, 0), new THREE.Vector3(-20, 0, 0), new THREE.Vector3(20, 0, 0)];
            for (let i = 0; i < 3; i++) {
                const waveSource = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshPhongMaterial({ color: waveSourceColors[i], shininess: 100 }));
                waveSource.position.copy(waveSourcePositions[i]);
                scene.add(waveSource);
                waveSources.push(waveSource);
            }

            // 相位波参数
            let waveSpeed = 5;
            let waveFrequency = 0.5;
            let waveAmplitude = 0.02;
            let waveTime = 0;

            function updateWaveParams() {
                waveSpeed = parseFloat(document.getElementById('waveSpeed').value);
                waveFrequency = parseFloat(document.getElementById('waveFrequency').value);
                waveAmplitude = parseFloat(document.getElementById('waveAmplitude').value);
                document.getElementById('info').textContent = `波速=${waveSpeed}, 频率=${waveFrequency}, 振幅=${waveAmplitude}`;
            }

            // 相位波传播
            function updatePhaseWave(nodesArr, materialsArr) {
                waveTime += dt;
                nodesArr.forEach((node, i) => {
                    let totalAmplitude = 0;
                    let totalPhase = 0;
                    waveSources.forEach((source, s) => {
                        const dist = node.position.distanceTo(source.position);
                        const phase = (waveTime * waveFrequency - dist / waveSpeed) * 2 * Math.PI + s * Math.PI / 3;
                        totalAmplitude += waveAmplitude * Math.sin(phase);
                        totalPhase += phase;

                        if (dist > 29.5 && Math.abs(totalAmplitude) > 0.015) {
                            boundaryStrength += 0.03;
                            for (let j = 0; j < 3; j++) createSpark(node.position);
                            node.position.multiplyScalar(29.4 / dist);
                        }
                    });
                    totalAmplitude /= waveSources.length;
                    const direction = new THREE.Vector3().subVectors(node.position, waveSources[0].position).normalize();
                    node.position.add(direction.multiplyScalar(totalAmplitude));

                    const color = new THREE.Color().setHSL((totalPhase % (2 * Math.PI)) / (2 * Math.PI), 1, 0.5);
                    materialsArr[i].color = color;
                });
            }

            // 两个粒子
            const particle1 = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 100 }));
            const particle2 = new THREE.Mesh(new THREE.SphereGeometry(0.3, 16, 16), new THREE.MeshPhongMaterial({ color: 0x0000ff, shininess: 100 }));
            particle1.position.set(5, 0, 0);
            particle2.position.set(-5, 0, 0);
            scene.add(particle1);
            scene.add(particle2);

            // 粒子连接
            const particleEdgeMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
            const particleEdgeGeometry = new THREE.BufferGeometry().setFromPoints([particle1.position, particle2.position]);
            const particleEdge = new THREE.Line(particleEdgeGeometry, particleEdgeMaterial);
            scene.add(particleEdge);

            // 粒子轨迹
            const trailMaterial = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.8 });
            const trail1 = new THREE.Line(new THREE.BufferGeometry(), trailMaterial);
            const trail2 = new THREE.Line(new THREE.BufferGeometry(), trailMaterial);
            scene.add(trail1);
            scene.add(trail2);
            const trailPoints1 = [];
            const trailPoints2 = [];
            const trailColors1 = [];
            const trailColors2 = [];
            const maxTrailLength = 100;

            // 粒子相互作用
            const k = 1;
            const q1 = 1, q2 = -1;
            let t = 0;
            const dt = 0.01;
            function updateParticleInteraction() {
                const r = particle1.position.distanceTo(particle2.position);
                if (r > 0.1) {
                    const force = k * q1 * q2 / (r * r);
                    const direction = new THREE.Vector3().subVectors(particle2.position, particle1.position).normalize();
                    const forceVector = direction.multiplyScalar(force / 100);
                    particle1.position.add(forceVector);
                    particle2.position.add(forceVector.clone().negate());

                    const dist1 = particle1.position.length();
                    const dist2 = particle2.position.length();
                    if (dist1 > 29.5 || dist2 > 29.5) {
                        boundaryStrength += 0.06;
                        boundaryWall.position.set(0, 0, Math.sin(Date.now() * 0.005) * 0.5);
                        for (let j = 0; j < 5; j++) {
                            if (dist1 > 29.5) createSpark(particle1.position);
                            if (dist2 > 29.5) createSpark(particle2.position);
                        }
                        if (dist1 > 29.5) particle1.position.multiplyScalar(29.4 / dist1);
                        if (dist2 > 29.5) particle2.position.multiplyScalar(29.4 / dist2);
                    }
                }
                particleEdge.geometry.setFromPoints([particle1.position, particle2.position]);
                particleEdge.geometry.attributes.position.needsUpdate = true;

                trailPoints1.push(particle1.position.clone());
                trailPoints2.push(particle2.position.clone());
                trailColors1.push(1, 1, 1);
                trailColors2.push(1, 0, 1);
                if (trailPoints1.length > maxTrailLength) {
                    trailPoints1.shift();
                    trailColors1.splice(0, 3);
                }
                if (trailPoints2.length > maxTrailLength) {
                    trailPoints2.shift();
                    trailColors2.splice(0, 3);
                }
                const trailGeometry1 = new THREE.BufferGeometry().setFromPoints(trailPoints1);
                trailGeometry1.setAttribute('color', new THREE.Float32BufferAttribute(trailColors1, 3));
                trail1.geometry = trailGeometry1;
                const trailGeometry2 = new THREE.BufferGeometry().setFromPoints(trailPoints2);
                trailGeometry2.setAttribute('color', new THREE.Float32BufferAttribute(trailColors2, 3));
                trail2.geometry = trailGeometry2;

                t += dt;
            }

            // 相机
            camera.position.z = 80;

            // 多视角切换
            let viewMode = 'free';
            let rotationAngle = 0;
            let zoomLevel = 80;
            let manualZoom = 80;
            let manualRotationSpeed = 0.0015;
            let sphereRadius = 100;
            let sphereSpeed = 0.003;
            let sphereAngleX = 0;
            let sphereAngleY = 0;
            let showParticles = true;
            
            // 强大存在
            const powerfulBeings = [];
            const powerfulInfluences = [];
            let powerfulCount = 3;
            let powerfulInfluenceRange = 15;
            
            // 二进制能级瀑布
            const energyLevels = [];
            const energyParticles = [];
            let energyLevelCount = 5;
            let waterfallSpeed = 1.5;
            let energyWaterfallActive = false;
            
            // 哥白尼闭环
            const copernicusNodes = [];
            const copernicusConnections = [];
            const copernicusDataFlowParticles = [];
            let copernicusLoopActive = false;
            let loopSpeed = 2;
            let dataFlowIntensity = 5;
            
            // 意识觉醒
            const consciousnessNodes = [];
            const consciousnessConnections = [];
            const awakeningParticles = [];
            let consciousnessActive = false;
            let consciousnessCount = 8;
            let awakeningSpeed = 1.5;
            
            // 时间箭头
            const timeArrow = [];
            const entropyParticles = [];
            let timeArrowActive = false;
            let timeArrowSpeed = 2;
            let entropyRate = 1;
            
            // 量子纠缠
            const entanglementPairs = [];
            const entanglementConnections = [];
            let entanglementActive = false;
            let entanglementPairCount = 5;
            let entanglementStrength = 1.5;
            
            // 关系重塑
            const reshapingNodes = [];
            const reshapingConnections = [];
            let reshapingActive = false;
            let reshapingSpeed = 1.5;
            let reshapingIntensity = 1;
            
            // 宇宙探测器
            const detector = [];
            const scanBeams = [];
            const dataParticles = [];
            let detectorActive = false;
            let detectorSpeed = 1.5;
            let scanRange = 30;
            
            // 观察者系统
            const observerNodes = [];
            const observerConnections = [];
            const observerInfluence = [];
            let observerActive = false;
            let observerMode = false;
            let observerCount = 0;
            let observerInfluenceRange = 10;
            
            // 内禀能量可视化系统
            const energySpheres = [];
            const energyConnections = [];
            const energyFlowParticles = [];
            let intrinsicEnergyActive = false;
            let energyFlowActive = false;
            let energyDensityActive = false;
            
            // 张量几何可视化系统
            const tensorGeometry = [];
            const tensorField = [];
            const tensorFlowParticles = [];
            let tensor3DGeometryActive = false;
            let tensorFieldActive = false;
            let tensorFlowActive = false;
            
            // 哥白尼计划双路径验证系统
            const reversePathNodes = [];
            const forwardPathNodes = [];
            const verificationConnections = [];
            const dualPathDataFlowParticles = [];
            let dualPathVerificationActive = false;
            let reversePathActive = false;
            let forwardPathActive = false;
            
            // 量子涨落可视化系统
            const quantumFluctuationParticles = [];
            const vacuumFluctuationWaves = [];
            const virtualParticles = [];
            let quantumFluctuationsActive = false;
            let vacuumFluctuationsActive = false;
            let virtualParticlesActive = false;
            
            // 节点数量控制
            let nodeCount = 2000;
            let targetNodeCount = 2000;
            function setView(mode) {
                viewMode = mode;
                document.getElementById('info').textContent = 
                    mode === 'front' ? `正面 (圆形投影，波速=${waveSpeed})` : 
                    mode === 'side' ? `侧面 (椭圆投影，波速=${waveSpeed})` : 
                    mode === 'rotate' ? `旋转多视角 (波速=${waveSpeed})` : 
                    mode === 'zoom' ? `缩放尺寸视角 (波速=${waveSpeed})` : 
                    mode === 'rotateZoom' ? `旋转+缩放视角 (波速=${waveSpeed})` : 
                    mode === 'manual' ? `手动视角 (缩放=${manualZoom}, 旋转=${manualRotationSpeed})` : 
                    mode === 'sphere360' ? `360°球体滚动 (半径=${sphereRadius}, 速度=${sphereSpeed})` : 
                    mode === 'free' ? `自由视角 (鼠标拖拽旋转, 滚轮缩放)` : '未选择';
            }
            function toggleParticles() {
                showParticles = !showParticles;
                particle1.visible = showParticles;
                particle2.visible = showParticles;
                particleEdge.visible = showParticles;
                trail1.visible = showParticles;
                trail2.visible = showParticles;
                document.getElementById('info').textContent = showParticles ? `粒子交互开启，波速=${waveSpeed}` : '粒子交互关闭';
            }
            function updateZoomScale() {
                manualZoom = parseFloat(document.getElementById('zoomScale').value);
                setView('manual');
                console.log(`手动缩放更新: ${manualZoom}`);
            }
            function updateRotationSpeed() {
                manualRotationSpeed = parseFloat(document.getElementById('rotationSpeed').value);
                setView('manual');
                console.log(`手动旋转速度更新: ${manualRotationSpeed}`);
            }
            function updateSphereRadius() {
                sphereRadius = parseFloat(document.getElementById('sphereRadius').value);
                setView('sphere360');
                console.log(`球体半径更新: ${sphereRadius}`);
            }
            function updateSphereSpeed() {
                sphereSpeed = parseFloat(document.getElementById('sphereSpeed').value);
                setView('sphere360');
                console.log(`球体滚动速度更新: ${sphereSpeed}`);
            }
            
            // 创建强大存在
            function createPowerfulBeings() {
                // 清除现有的强大存在
                powerfulBeings.forEach(being => scene.remove(being));
                powerfulInfluences.forEach(influence => scene.remove(influence));
                powerfulBeings.length = 0;
                powerfulInfluences.length = 0;
                
                // 创建新的强大存在
                for (let i = 0; i < powerfulCount; i++) {
                    const being = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8, 16, 16),
                        new THREE.MeshPhongMaterial({ color: 0x00ffff, shininess: 100 })
                    );
                    being.position.set(
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40
                    );
                    scene.add(being);
                    powerfulBeings.push(being);
                    
                    // 创建影响力范围
                    const influence = new THREE.Mesh(
                        new THREE.SphereGeometry(powerfulInfluenceRange, 16, 16),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ffff, 
                            transparent: true, 
                            opacity: 0.1,
                            side: THREE.DoubleSide
                        })
                    );
                    influence.position.copy(being.position);
                    scene.add(influence);
                    powerfulInfluences.push(influence);
                }
                document.getElementById('info').textContent = `创建了${powerfulCount}个强大存在！`;
            }
            
            function updatePowerfulBeings() {
                powerfulCount = parseInt(document.getElementById('powerfulCount').value);
                powerfulInfluenceRange = parseFloat(document.getElementById('powerfulInfluence').value);
                createPowerfulBeings();
            }
            
            // 创建二进制能级瀑布
            function createEnergyWaterfall() {
                // 清除现有的能级瀑布
                energyLevels.forEach(level => scene.remove(level));
                energyParticles.forEach(particle => scene.remove(particle));
                energyLevels.length = 0;
                energyParticles.length = 0;
                
                // 创建能级层 - 基于QSDT理论 E_n = M_H/2^n
                for (let level = 0; level < energyLevelCount; level++) {
                    const levelY = 30 - level * 8; // 从高到低排列，调整高度
                    const levelRadius = 8 + level * 2; // 层级越高，半径越大，但控制在宇宙内
                    const energyValue = Math.pow(2, level); // 二进制能级：1, 2, 4, 8, 16...
                    
                    // 创建能级环
                    const levelRing = new THREE.Mesh(
                        new THREE.TorusGeometry(levelRadius, 0.8, 8, 32),
                        new THREE.MeshPhongMaterial({ 
                            color: new THREE.Color().setHSL(level / energyLevelCount, 1, 0.5),
                            transparent: true,
                            opacity: 0.7
                        })
                    );
                    levelRing.position.y = levelY;
                    levelRing.userData = { level, energyValue, radius: levelRadius };
                    scene.add(levelRing);
                    energyLevels.push(levelRing);
                    
                    // 创建能级粒子 - 数量对应能级值
                    const particleCount = Math.min(energyValue, 16); // 限制最大粒子数
                    for (let i = 0; i < particleCount; i++) {
                        const particle = new THREE.Mesh(
                            new THREE.SphereGeometry(0.15, 8, 8),
                            new THREE.MeshPhongMaterial({ 
                                color: new THREE.Color().setHSL(level / energyLevelCount, 1, 0.8)
                            })
                        );
                        const angle = (i / particleCount) * Math.PI * 2;
                        particle.position.set(
                            Math.cos(angle) * levelRadius,
                            levelY,
                            Math.sin(angle) * levelRadius
                        );
                        particle.userData = { 
                            level, 
                            angle, 
                            radius: levelRadius, 
                            energyValue,
                            fallSpeed: 0,
                            targetLevel: level,
                            isFalling: false
                        };
                        scene.add(particle);
                        energyParticles.push(particle);
                    }
                }
                energyWaterfallActive = true;
                document.getElementById('info').textContent = `创建了${energyLevelCount}层二进制能级瀑布！能量级联：${Math.pow(2, energyLevelCount-1)}`;
            }
            
            function updateEnergyWaterfall() {
                energyLevelCount = parseInt(document.getElementById('energyLevels').value);
                waterfallSpeed = parseFloat(document.getElementById('waterfallSpeed').value);
                createEnergyWaterfall();
            }
            
            // 启动哥白尼闭环
            function startCopernicusLoop() {
                // 清除现有的哥白尼闭环
                copernicusNodes.forEach(node => scene.remove(node));
                copernicusConnections.forEach(conn => scene.remove(conn));
                copernicusDataFlowParticles.forEach(particle => scene.remove(particle));
                copernicusNodes.length = 0;
                copernicusConnections.length = 0;
                copernicusDataFlowParticles.length = 0;
                
                // 创建哥白尼闭环节点：反推-正推-验证
                const nodePositions = [
                    new THREE.Vector3(-30, 0, 0),  // 反推
                    new THREE.Vector3(0, 30, 0),   // 正推
                    new THREE.Vector3(30, 0, 0),   // 验证
                    new THREE.Vector3(0, -30, 0)   // 反馈
                ];
                const nodeColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00];
                const nodeLabels = ['反推', '正推', '验证', '反馈'];
                
                nodePositions.forEach((pos, i) => {
                    const node = new THREE.Mesh(
                        new THREE.SphereGeometry(1, 16, 16),
                        new THREE.MeshPhongMaterial({ color: nodeColors[i], shininess: 100 })
                    );
                    node.position.copy(pos);
                    scene.add(node);
                    copernicusNodes.push(node);
                });
                
                // 创建闭环连接
                for (let i = 0; i < nodePositions.length; i++) {
                    const nextIndex = (i + 1) % nodePositions.length;
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        nodePositions[i],
                        nodePositions[nextIndex]
                    ]);
                    const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                        color: 0xffffff, 
                        transparent: true, 
                        opacity: 0.8 
                    }));
                    scene.add(connection);
                    copernicusConnections.push(connection);
                }
                
                copernicusLoopActive = true;
                document.getElementById('info').textContent = '哥白尼闭环启动！';
            }
            
            function updateCopernicusLoop() {
                loopSpeed = parseFloat(document.getElementById('loopSpeed').value);
                dataFlowIntensity = parseInt(document.getElementById('dataFlow').value);
            }
            
            // 创建意识觉醒节点
            function createConsciousnessNodes() {
                // 清除现有的意识节点
                consciousnessNodes.forEach(node => scene.remove(node));
                consciousnessConnections.forEach(conn => scene.remove(conn));
                awakeningParticles.forEach(particle => scene.remove(particle));
                consciousnessNodes.length = 0;
                consciousnessConnections.length = 0;
                awakeningParticles.length = 0;
                
                // 创建意识节点
                for (let i = 0; i < consciousnessCount; i++) {
                    const node = new THREE.Mesh(
                        new THREE.SphereGeometry(0.6, 16, 16),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff00ff, 
                            shininess: 100,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    node.position.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    node.userData = { 
                        awakeningLevel: Math.random(),
                        connections: []
                    };
                    scene.add(node);
                    consciousnessNodes.push(node);
                }
                
                // 创建意识连接
                for (let i = 0; i < consciousnessNodes.length; i++) {
                    for (let j = i + 1; j < consciousnessNodes.length; j++) {
                        if (Math.random() < 0.3) { // 30%概率连接
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                consciousnessNodes[i].position,
                                consciousnessNodes[j].position
                            ]);
                            const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                                color: 0xff00ff, 
                                transparent: true, 
                                opacity: 0.5 
                            }));
                            scene.add(connection);
                            consciousnessConnections.push(connection);
                            consciousnessNodes[i].userData.connections.push(j);
                            consciousnessNodes[j].userData.connections.push(i);
                        }
                    }
                }
                
                consciousnessActive = true;
                document.getElementById('info').textContent = `创建了${consciousnessCount}个意识觉醒节点！`;
            }
            
            function updateConsciousnessNodes() {
                consciousnessCount = parseInt(document.getElementById('consciousnessCount').value);
                awakeningSpeed = parseFloat(document.getElementById('awakeningSpeed').value);
                createConsciousnessNodes();
            }
            
            // 创建时间箭头
            function createTimeArrow() {
                // 清除现有的时间箭头
                timeArrow.forEach(arrow => scene.remove(arrow));
                entropyParticles.forEach(particle => scene.remove(particle));
                timeArrow.length = 0;
                entropyParticles.length = 0;
                
                // 创建时间箭头（从过去指向未来）
                const arrowGeometry = new THREE.ConeGeometry(2, 20, 8);
                const arrowMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff6600, 
                    shininess: 100,
                    transparent: true,
                    opacity: 0.8
                });
                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                arrow.position.set(0, 0, -40);
                arrow.rotation.x = Math.PI / 2;
                scene.add(arrow);
                timeArrow.push(arrow);
                
                // 创建熵增粒子流
                for (let i = 0; i < 20; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff6600,
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    particle.position.set(
                        (Math.random() - 0.5) * 10,
                        (Math.random() - 0.5) * 10,
                        -40 + i * 2
                    );
                    particle.userData = { 
                        speed: Math.random() * 0.5 + 0.5,
                        entropy: Math.random()
                    };
                    scene.add(particle);
                    entropyParticles.push(particle);
                }
                
                timeArrowActive = true;
                document.getElementById('info').textContent = '时间箭头创建！熵增不可逆！';
            }
            
            function updateTimeArrow() {
                timeArrowSpeed = parseFloat(document.getElementById('timeArrowSpeed').value);
                entropyRate = parseFloat(document.getElementById('entropyRate').value);
            }
            
            // 创建量子纠缠
            function createQuantumEntanglement() {
                // 清除现有的量子纠缠
                entanglementPairs.forEach(pair => {
                    scene.remove(pair.particle1);
                    scene.remove(pair.particle2);
                });
                entanglementConnections.forEach(conn => scene.remove(conn));
                entanglementPairs.length = 0;
                entanglementConnections.length = 0;
                
                // 创建纠缠粒子对
                for (let i = 0; i < entanglementPairCount; i++) {
                    const pair = {
                        particle1: new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 16, 16),
                            new THREE.MeshPhongMaterial({ 
                                color: 0x00ff00, 
                                shininess: 100,
                                transparent: true,
                                opacity: 0.8
                            })
                        ),
                        particle2: new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 16, 16),
                            new THREE.MeshPhongMaterial({ 
                                color: 0xff0000, 
                                shininess: 100,
                                transparent: true,
                                opacity: 0.8
                            })
                        )
                    };
                    
                    // 随机位置
                    const pos1 = new THREE.Vector3(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    const pos2 = new THREE.Vector3(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    
                    pair.particle1.position.copy(pos1);
                    pair.particle2.position.copy(pos2);
                    pair.particle1.userData = { 
                        entangledWith: pair.particle2,
                        phase: Math.random() * Math.PI * 2
                    };
                    pair.particle2.userData = { 
                        entangledWith: pair.particle1,
                        phase: Math.random() * Math.PI * 2
                    };
                    
                    scene.add(pair.particle1);
                    scene.add(pair.particle2);
                    entanglementPairs.push(pair);
                    
                    // 创建纠缠连接线
                    const geometry = new THREE.BufferGeometry().setFromPoints([pos1, pos2]);
                    const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                        color: 0xffff00, 
                        transparent: true, 
                        opacity: 0.6 
                    }));
                    scene.add(connection);
                    entanglementConnections.push(connection);
                }
                
                entanglementActive = true;
                document.getElementById('info').textContent = `创建了${entanglementPairCount}对量子纠缠！`;
            }
            
            function updateQuantumEntanglement() {
                entanglementPairCount = parseInt(document.getElementById('entanglementPairs').value);
                entanglementStrength = parseFloat(document.getElementById('entanglementStrength').value);
                createQuantumEntanglement();
            }
            
            // 创建关系重塑过程
            function createRelationshipReshaping() {
                // 清除现有的关系重塑
                reshapingNodes.forEach(node => scene.remove(node));
                reshapingConnections.forEach(conn => scene.remove(conn));
                reshapingNodes.length = 0;
                reshapingConnections.length = 0;
                
                // 创建关系重塑节点
                for (let i = 0; i < 12; i++) {
                    const node = new THREE.Mesh(
                        new THREE.SphereGeometry(0.4, 16, 16),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ffff, 
                            shininess: 100,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    node.position.set(
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50,
                        (Math.random() - 0.5) * 50
                    );
                    node.userData = { 
                        originalPosition: node.position.clone(),
                        reshapingPhase: Math.random() * Math.PI * 2,
                        connectionStrength: Math.random()
                    };
                    scene.add(node);
                    reshapingNodes.push(node);
                }
                
                // 创建动态连接
                for (let i = 0; i < reshapingNodes.length; i++) {
                    for (let j = i + 1; j < reshapingNodes.length; j++) {
                        if (Math.random() < 0.4) { // 40%概率连接
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                reshapingNodes[i].position,
                                reshapingNodes[j].position
                            ]);
                            const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                                color: 0x00ffff, 
                                transparent: true, 
                                opacity: 0.5 
                            }));
                            scene.add(connection);
                            reshapingConnections.push(connection);
                        }
                    }
                }
                
                reshapingActive = true;
                document.getElementById('info').textContent = '关系重塑过程启动！';
            }
            
            function updateRelationshipReshaping() {
                reshapingSpeed = parseFloat(document.getElementById('reshapingSpeed').value);
                reshapingIntensity = parseFloat(document.getElementById('reshapingIntensity').value);
            }
            
            // 创建宇宙探测器
            function createUniverseDetector() {
                // 清除现有的探测器
                detector.forEach(d => scene.remove(d));
                scanBeams.forEach(beam => scene.remove(beam));
                dataParticles.forEach(particle => scene.remove(particle));
                detector.length = 0;
                scanBeams.length = 0;
                dataParticles.length = 0;
                
                // 创建探测器主体
                const detectorBody = new THREE.Mesh(
                    new THREE.BoxGeometry(2, 2, 2),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xffffff, 
                        shininess: 100,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                detectorBody.position.set(0, 0, 0);
                scene.add(detectorBody);
                detector.push(detectorBody);
                
                // 创建扫描光束
                for (let i = 0; i < 8; i++) {
                    const beam = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, scanRange, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00, 
                            transparent: true, 
                            opacity: 0.6 
                        })
                    );
                    beam.position.set(0, 0, 0);
                    beam.rotation.x = Math.PI / 2;
                    beam.rotation.z = (i / 8) * Math.PI * 2;
                    beam.userData = { 
                        angle: (i / 8) * Math.PI * 2,
                        speed: Math.random() * 0.5 + 0.5
                    };
                    scene.add(beam);
                    scanBeams.push(beam);
                }
                
                // 创建数据粒子
                for (let i = 0; i < 15; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    particle.position.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    particle.userData = { 
                        targetPosition: particle.position.clone(),
                        scanPhase: Math.random() * Math.PI * 2
                    };
                    scene.add(particle);
                    dataParticles.push(particle);
                }
                
                detectorActive = true;
                document.getElementById('info').textContent = '宇宙探测器启动！开始扫描！';
            }
            
            function updateUniverseDetector() {
                detectorSpeed = parseFloat(document.getElementById('detectorSpeed').value);
                scanRange = parseFloat(document.getElementById('scanRange').value);
            }
            
            // 重置视角和所有元素
            function resetView() {
                // 重置所有视角参数
                mouseWheelZoom = 80;
                mouseRotationX = 0;
                mouseRotationY = 0;
                rotationAngle = 0;
                zoomLevel = 80;
                sphereAngleX = 0;
                sphereAngleY = 0;
                sphereRadius = 100;
                
                // 重置到自由视角
                setView('free');
                camera.position.set(0, 0, 80);
                camera.lookAt(0, 0, 0);
                
                // 清除所有理论元素
                clearAllElements();
                
                // 重新生成基础网络
                generateMotherUniverse();
                
                document.getElementById('info').textContent = '已重置到默认状态：基础量子空间网络（自由视角模式）';
            }
            
            // 清除所有理论元素
            function clearAllElements() {
                // 清除强大存在
                powerfulBeings.forEach(being => scene.remove(being));
                powerfulInfluences.forEach(influence => scene.remove(influence));
                powerfulBeings.length = 0;
                powerfulInfluences.length = 0;
                
                // 清除能级瀑布
                energyLevels.forEach(level => scene.remove(level));
                energyParticles.forEach(particle => scene.remove(particle));
                energyLevels.length = 0;
                energyParticles.length = 0;
                energyWaterfallActive = false;
                
                // 清除哥白尼闭环
                copernicusNodes.forEach(node => scene.remove(node));
                copernicusConnections.forEach(conn => scene.remove(conn));
                copernicusDataFlowParticles.forEach(particle => scene.remove(particle));
                copernicusNodes.length = 0;
                copernicusConnections.length = 0;
                copernicusDataFlowParticles.length = 0;
                copernicusLoopActive = false;
                
                // 清除意识觉醒
                consciousnessNodes.forEach(node => scene.remove(node));
                consciousnessConnections.forEach(conn => scene.remove(conn));
                awakeningParticles.forEach(particle => scene.remove(particle));
                consciousnessNodes.length = 0;
                consciousnessConnections.length = 0;
                awakeningParticles.length = 0;
                consciousnessActive = false;
                
                // 清除时间箭头
                timeArrow.forEach(arrow => scene.remove(arrow));
                entropyParticles.forEach(particle => scene.remove(particle));
                timeArrow.length = 0;
                entropyParticles.length = 0;
                timeArrowActive = false;
                
                // 清除量子纠缠
                entanglementPairs.forEach(pair => {
                    scene.remove(pair.particle1);
                    scene.remove(pair.particle2);
                });
                entanglementConnections.forEach(conn => scene.remove(conn));
                entanglementPairs.length = 0;
                entanglementConnections.length = 0;
                entanglementActive = false;
                
                // 清除关系重塑
                reshapingNodes.forEach(node => scene.remove(node));
                reshapingConnections.forEach(conn => scene.remove(conn));
                reshapingNodes.length = 0;
                reshapingConnections.length = 0;
                reshapingActive = false;
                
                // 清除宇宙探测器
                detector.forEach(d => scene.remove(d));
                scanBeams.forEach(beam => scene.remove(beam));
                dataParticles.forEach(particle => scene.remove(particle));
                detector.length = 0;
                scanBeams.length = 0;
                dataParticles.length = 0;
                detectorActive = false;
                
                // 清除观察者
                observerNodes.forEach(node => scene.remove(node));
                observerConnections.forEach(conn => scene.remove(conn));
                observerInfluence.forEach(influence => scene.remove(influence));
                observerNodes.length = 0;
                observerConnections.length = 0;
                observerInfluence.length = 0;
                observerActive = false;
                observerMode = false;
                
                // 清除内禀能量可视化
                energySpheres.forEach(sphere => scene.remove(sphere));
                energyConnections.forEach(conn => scene.remove(conn));
                energyFlowParticles.forEach(particle => scene.remove(particle));
                energySpheres.length = 0;
                energyConnections.length = 0;
                energyFlowParticles.length = 0;
                intrinsicEnergyActive = false;
                energyFlowActive = false;
                energyDensityActive = false;
                
                // 清除张量几何可视化
                tensorGeometry.forEach(geometry => scene.remove(geometry));
                tensorField.forEach(field => scene.remove(field));
                tensorFlowParticles.forEach(particle => scene.remove(particle));
                tensorGeometry.length = 0;
                tensorField.length = 0;
                tensorFlowParticles.length = 0;
                tensor3DGeometryActive = false;
                tensorFieldActive = false;
                tensorFlowActive = false;
                
                // 清除哥白尼计划双路径验证
                reversePathNodes.forEach(node => scene.remove(node));
                forwardPathNodes.forEach(node => scene.remove(node));
                verificationConnections.forEach(conn => scene.remove(conn));
                dualPathDataFlowParticles.forEach(particle => scene.remove(particle));
                reversePathNodes.length = 0;
                forwardPathNodes.length = 0;
                verificationConnections.length = 0;
                dualPathDataFlowParticles.length = 0;
                dualPathVerificationActive = false;
                reversePathActive = false;
                forwardPathActive = false;
                
                // 清除量子涨落可视化
                quantumFluctuationParticles.forEach(particle => scene.remove(particle));
                vacuumFluctuationWaves.forEach(wave => scene.remove(wave));
                virtualParticles.forEach(particle => scene.remove(particle));
                quantumFluctuationParticles.length = 0;
                vacuumFluctuationWaves.length = 0;
                virtualParticles.length = 0;
                quantumFluctuationsActive = false;
                vacuumFluctuationsActive = false;
                virtualParticlesActive = false;
                
                // 隐藏所有面板
                document.getElementById('mathVisualization').style.display = 'none';
                document.getElementById('detailedGuide').style.display = 'block'; // 保持理论详解显示
            }
            
            // 切换控制面板显示/隐藏
            function toggleControls() {
                const controls = document.getElementById('controls');
                const toggleButton = document.querySelector('#instructions button');
                
                if (controls.style.display === 'none') {
                    controls.style.display = 'block';
                    toggleButton.textContent = '隐藏控制面板';
                } else {
                    controls.style.display = 'none';
                    toggleButton.textContent = '显示控制面板';
                }
            }
            
            // 切换使用说明面板显示/隐藏
            function toggleInstructions() {
                const instructions = document.getElementById('instructions');
                const toggleButton = document.querySelector('#instructions button:nth-last-child(2)');
                
                if (instructions.style.display === 'none') {
                    instructions.style.display = 'block';
                    toggleButton.textContent = '隐藏说明';
                } else {
                    instructions.style.display = 'none';
                    toggleButton.textContent = '显示说明';
                }
            }
            
            // 切换理论详解面板显示/隐藏
            function toggleDetailedGuide() {
                const detailedGuide = document.getElementById('detailedGuide');
                const toggleButton = document.querySelector('#instructions button:last-child');
                
                if (detailedGuide.style.display === 'none') {
                    detailedGuide.style.display = 'block';
                    toggleButton.textContent = '关闭说明';
                } else {
                    detailedGuide.style.display = 'none';
                    toggleButton.textContent = '理论详解';
                }
            }
            
            // 更新节点数量
            function updateNodeCount() {
                targetNodeCount = parseInt(document.getElementById('nodeCount').value);
                document.getElementById('info').textContent = `目标节点数量: ${targetNodeCount}`;
                updatePerformanceHint();
            }
            
            // 更新性能提示
            function updatePerformanceHint() {
                const performanceDiv = document.getElementById('performance');
                if (targetNodeCount <= 500) {
                    performanceDiv.textContent = `性能提示：节点数量 ${targetNodeCount}，性能优秀`;
                    performanceDiv.style.color = '#00ff00';
                } else if (targetNodeCount <= 2000) {
                    performanceDiv.textContent = `性能提示：节点数量 ${targetNodeCount}，性能良好`;
                    performanceDiv.style.color = '#ffff00';
                } else if (targetNodeCount <= 3500) {
                    performanceDiv.textContent = `性能提示：节点数量 ${targetNodeCount}，性能一般`;
                    performanceDiv.style.color = '#ff8800';
                } else {
                    performanceDiv.textContent = `性能提示：节点数量 ${targetNodeCount}，性能较差，建议降低`;
                    performanceDiv.style.color = '#ff0000';
                }
            }
            
            // 重新生成网络
            function regenerateNetwork() {
                // 清除现有网络
                motherNodes.forEach(node => scene.remove(node));
                motherEdges.forEach(({ edge }) => scene.remove(edge));
                motherNodes.length = 0;
                motherEdges.length = 0;
                
                // 清除子宇宙
                subNodes.forEach(node => scene.remove(node));
                subEdges.forEach(({ edge }) => scene.remove(edge));
                subNodes.length = 0;
                subEdges.length = 0;
                subUniverseGenerated = false;
                
                // 清除子母宇宙连接
                universeConnections.forEach(({ edge }) => scene.remove(edge));
                universeConnections.length = 0;
                
                // 重新生成母宇宙
                nodeCount = targetNodeCount;
                generateMotherUniverse();
                
                document.getElementById('info').textContent = `网络重新生成完成！节点数量: ${nodeCount}`;
                updatePerformanceHint();
            }
            
            // 生成母宇宙（重构为独立函数）
            function generateMotherUniverse() {
                // 创建母宇宙节点
                const motherGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const motherMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00, shininess: 100 });
                
                for (let i = 0; i < nodeCount; i++) {
                    const node = new THREE.Mesh(motherGeometry, motherMaterial.clone());
                    node.position.set(
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40,
                        (Math.random() - 0.5) * 40
                    );
                    scene.add(node);
                    motherNodes.push(node);
                    motherMaterials.push(node.material);
                }
                
                // 创建母宇宙连接（动态调整连接概率以保持性能）
                let edgeCount = 0;
                const maxEdges = Math.min(5000, nodeCount * 2); // 最大边数限制
                const connectionProbability = Math.min(0.02, 10000 / (nodeCount * nodeCount)); // 动态连接概率
                
                for (let i = 0; i < nodeCount && edgeCount < maxEdges; i++) {
                    for (let j = i + 1; j < nodeCount && edgeCount < maxEdges; j++) {
                        if (Math.random() < connectionProbability) {
                            const geometry = new THREE.BufferGeometry().setFromPoints([
                                motherNodes[i].position,
                                motherNodes[j].position
                            ]);
                            const edge = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3 }));
                            scene.add(edge);
                            motherEdges.push({ edge, startIdx: i, endIdx: j });
                            edgeCount++;
                        }
                    }
                }
            }

            // 动画循环
            function animate() {
                requestAnimationFrame(animate);

                // 母宇宙压缩
                motherNodes.forEach(node => {
                    node.position.multiplyScalar(motherCompressFactor);
                });
                motherEdges.forEach(({ edge, startIdx, endIdx }) => {
                    const positions = edge.geometry.attributes.position.array;
                    positions[0] = motherNodes[startIdx].position.x;
                    positions[1] = motherNodes[startIdx].position.y;
                    positions[2] = motherNodes[startIdx].position.z;
                    positions[3] = motherNodes[endIdx].position.x;
                    positions[4] = motherNodes[endIdx].position.y;
                    positions[5] = motherNodes[endIdx].position.z;
                    edge.geometry.attributes.position.needsUpdate = true;
                });

                // 子母宇宙连接闪烁
                universeConnections.forEach(({ edge, motherIdx, subIdx }) => {
                    const positions = edge.geometry.attributes.position.array;
                    positions[0] = motherNodes[motherIdx].position.x;
                    positions[1] = motherNodes[motherIdx].position.y;
                    positions[2] = motherNodes[motherIdx].position.z;
                    positions[3] = subNodes[subIdx].position.x;
                    positions[4] = subNodes[subIdx].position.y;
                    positions[5] = subNodes[subIdx].position.z;
                    edge.geometry.attributes.position.needsUpdate = true;
                    edge.material.opacity = 0.7 + Math.sin(Date.now() * 0.002) * 0.2;
                });

                // 相位波传播
                updatePhaseWave(motherNodes, motherMaterials);
                if (subUniverseGenerated) updatePhaseWave(subNodes, subMaterials);

                // 粒子交互
                if (showParticles) updateParticleInteraction();

                // 边界墙颜色与振动
                boundaryStrength = Math.max(0, boundaryStrength - 0.003);
                boundaryMaterial.color.setHSL(boundaryStrength % 1, 1, 0.5);
                boundaryMaterial.opacity = Math.min(0.9, 0.3 + boundaryStrength);
                boundaryWall.position.set(0, 0, Math.sin(Date.now() * 0.005) * 0.5);

                // 冲破火花更新
                sparks.forEach((spark, i) => {
                    spark.position.add(spark.velocity);
                    if (spark.position.length() > 35) {
                        scene.remove(spark);
                        sparks.splice(i, 1);
                    }
                });

                // 强大存在动画
                powerfulBeings.forEach((being, i) => {
                    being.rotation.y += 0.01;
                    being.rotation.x += 0.005;
                    powerfulInfluences[i].rotation.y += 0.005;
                    powerfulInfluences[i].material.opacity = 0.1 + Math.sin(Date.now() * 0.001 + i) * 0.05;
                });

                // 能级瀑布动画
                if (energyWaterfallActive) {
                    energyParticles.forEach((particle, i) => {
                        const userData = particle.userData;
                        
                        // 粒子在能级上旋转
                        userData.angle += waterfallSpeed * 0.01;
                        particle.position.x = Math.cos(userData.angle) * userData.radius;
                        particle.position.z = Math.sin(userData.angle) * userData.radius;
                        
                        // 瀑布效果：粒子从高能级向低能级跃迁
                        if (Math.random() < 0.02 * waterfallSpeed && userData.level > 0) {
                            // 开始向下一能级跃迁
                            userData.isFalling = true;
                            userData.targetLevel = userData.level - 1;
                            userData.fallSpeed = 0.5;
                        }
                        
                        // 处理粒子跃迁
                        if (userData.isFalling) {
                            userData.fallSpeed += 0.1; // 加速下落
                            particle.position.y -= userData.fallSpeed;
                            
                            // 到达目标能级
                            const targetY = 30 - userData.targetLevel * 8;
                            if (particle.position.y <= targetY) {
                                particle.position.y = targetY;
                                userData.level = userData.targetLevel;
                                userData.isFalling = false;
                                userData.fallSpeed = 0;
                                
                                // 更新粒子颜色和半径
                                const newRadius = 8 + userData.targetLevel * 2;
                                userData.radius = newRadius;
                                particle.material.color.setHSL(userData.targetLevel / energyLevelCount, 1, 0.8);
                            }
                        } else {
                            // 正常能级上的轻微波动
                            particle.position.y += Math.sin(Date.now() * 0.001 + i) * 0.01;
                        }
                    });
                }

                // 哥白尼闭环动画
                if (copernicusLoopActive) {
                    copernicusNodes.forEach((node, i) => {
                        node.rotation.y += loopSpeed * 0.01;
                        node.material.opacity = 0.8 + Math.sin(Date.now() * 0.002 + i) * 0.2;
                    });
                }

                // 意识觉醒动画
                if (consciousnessActive) {
                    consciousnessNodes.forEach((node, i) => {
                        node.userData.awakeningLevel += awakeningSpeed * 0.01;
                        node.material.opacity = 0.8 + Math.sin(node.userData.awakeningLevel) * 0.2;
                        node.rotation.y += awakeningSpeed * 0.005;
                        node.position.y += Math.sin(Date.now() * 0.001 + i) * 0.01;
                    });
                }
                
                // 时间箭头动画
                if (timeArrowActive) {
                    timeArrow.forEach(arrow => {
                        arrow.rotation.y += timeArrowSpeed * 0.01;
                        arrow.material.opacity = 0.8 + Math.sin(Date.now() * 0.002) * 0.2;
                    });
                    entropyParticles.forEach((particle, i) => {
                        particle.position.z += particle.userData.speed * timeArrowSpeed * 0.1;
                        particle.userData.entropy += entropyRate * 0.01;
                        particle.material.opacity = 0.6 + Math.sin(particle.userData.entropy) * 0.3;
                        if (particle.position.z > 40) {
                            particle.position.z = -40;
                        }
                    });
                }
                
                // 量子纠缠动画
                if (entanglementActive) {
                    entanglementPairs.forEach((pair, i) => {
                        pair.particle1.userData.phase += entanglementStrength * 0.02;
                        pair.particle2.userData.phase += entanglementStrength * 0.02;
                        
                        // 纠缠粒子同步运动
                        const phase1 = pair.particle1.userData.phase;
                        const phase2 = pair.particle2.userData.phase;
                        
                        pair.particle1.position.x += Math.sin(phase1) * 0.01;
                        pair.particle1.position.y += Math.cos(phase1) * 0.01;
                        pair.particle2.position.x += Math.sin(phase2 + Math.PI) * 0.01;
                        pair.particle2.position.y += Math.cos(phase2 + Math.PI) * 0.01;
                        
                        // 更新连接线
                        const connection = entanglementConnections[i];
                        if (connection) {
                            const positions = connection.geometry.attributes.position.array;
                            positions[0] = pair.particle1.position.x;
                            positions[1] = pair.particle1.position.y;
                            positions[2] = pair.particle1.position.z;
                            positions[3] = pair.particle2.position.x;
                            positions[4] = pair.particle2.position.y;
                            positions[5] = pair.particle2.position.z;
                            connection.geometry.attributes.position.needsUpdate = true;
                        }
                    });
                }
                
                // 关系重塑动画
                if (reshapingActive) {
                    reshapingNodes.forEach((node, i) => {
                        node.userData.reshapingPhase += reshapingSpeed * 0.02;
                        const phase = node.userData.reshapingPhase;
                        
                        // 节点位置重塑
                        const offset = new THREE.Vector3(
                            Math.sin(phase) * reshapingIntensity * 2,
                            Math.cos(phase * 1.3) * reshapingIntensity * 2,
                            Math.sin(phase * 0.7) * reshapingIntensity * 2
                        );
                        node.position.copy(node.userData.originalPosition).add(offset);
                        
                        // 连接强度变化
                        node.userData.connectionStrength = 0.5 + Math.sin(phase) * 0.5;
                        node.material.opacity = 0.8 + Math.sin(phase) * 0.2;
                    });
                }
                
                // 宇宙探测器动画
                if (detectorActive) {
                    detector.forEach(d => {
                        d.rotation.y += detectorSpeed * 0.01;
                        d.rotation.x += detectorSpeed * 0.005;
                    });
                    
                    scanBeams.forEach((beam, i) => {
                        beam.userData.angle += detectorSpeed * 0.02;
                        beam.rotation.z = beam.userData.angle;
                        beam.material.opacity = 0.6 + Math.sin(Date.now() * 0.003 + i) * 0.3;
                    });
                    
                    dataParticles.forEach((particle, i) => {
                        particle.userData.scanPhase += detectorSpeed * 0.01;
                        const phase = particle.userData.scanPhase;
                        
                        // 数据粒子向探测器移动
                        const direction = new THREE.Vector3().subVectors(
                            new THREE.Vector3(0, 0, 0), 
                            particle.position
                        ).normalize();
                        particle.position.add(direction.multiplyScalar(0.1));
                        
                        // 扫描效果
                        particle.material.opacity = 0.8 + Math.sin(phase) * 0.2;
                        particle.rotation.y += detectorSpeed * 0.01;
                    });
                }
                
                // 实时更新数学结构可视化参数
                if (document.getElementById('mathVisualization').style.display === 'block') {
                    updateHamiltonianValues();
                    updateTensorValues();
                    updateBetaFunctionValues();
                    updatePhysicalConstants();
                }
                
                // 观察者动画
                if (observerActive) {
                    observerNodes.forEach((observer, i) => {
                        observer.userData.observationPhase += 0.02;
                        const phase = observer.userData.observationPhase;
                        
                        // 观察者节点旋转和亮度变化
                        observer.rotation.y += 0.01;
                        observer.rotation.x += 0.005;
                        observer.material.opacity = 0.9 + Math.sin(phase) * 0.1;
                        
                        // 影响范围动画
                        if (observerInfluence[i]) {
                            observerInfluence[i].rotation.y += 0.005;
                            observerInfluence[i].material.opacity = 0.1 + Math.sin(phase * 0.5) * 0.05;
                        }
                    });
                    
                    // 观察者模式下的网络影响
                    if (observerMode) {
                        updateNetworkBasedOnObservers();
                    }
                }
                
                // 内禀能量动画
                if (intrinsicEnergyActive) {
                    energySpheres.forEach((sphere, i) => {
                        // 能量球上下浮动
                        sphere.position.y = sphere.userData.originalY + Math.sin(Date.now() * 0.001 + i) * 0.5;
                        
                        // 能量球旋转
                        sphere.rotation.x += 0.01;
                        sphere.rotation.y += 0.02;
                        
                        // 能量球颜色变化
                        const energy = sphere.userData.intrinsicEnergy;
                        const hue = (energy * 0.3 + Date.now() * 0.0001) % 1;
                        sphere.material.color.setHSL(hue, 1, 0.7);
                        
                        // 更新连接线
                        const connection = energyConnections[i];
                        if (connection) {
                            const node = motherNodes[sphere.userData.nodeIndex];
                            if (node) {
                                connection.geometry.setFromPoints([
                                    node.position,
                                    sphere.position
                                ]);
                            }
                        }
                    });
                }
                
                // 能量流动动画
                if (energyFlowActive) {
                    energyFlowParticles.forEach(particle => {
                        // 粒子运动
                        particle.position.add(particle.userData.velocity);
                        
                        // 边界检测和反弹
                        if (Math.abs(particle.position.x) > 30) particle.userData.velocity.x *= -1;
                        if (Math.abs(particle.position.y) > 30) particle.userData.velocity.y *= -1;
                        if (Math.abs(particle.position.z) > 30) particle.userData.velocity.z *= -1;
                        
                        // 能量影响颜色
                        const energy = particle.userData.energy;
                        particle.material.color.setHSL(0.5 + energy * 0.1, 1, 0.7);
                        
                        // 能量影响大小
                        const scale = 0.5 + energy * 0.5;
                        particle.scale.setScalar(scale);
                    });
                }
                
                // 张量几何动画
                if (tensor3DGeometryActive) {
                    tensorGeometry.forEach((ellipsoid, i) => {
                        // 张量椭球体旋转
                        ellipsoid.rotation.x += 0.01;
                        ellipsoid.rotation.y += 0.02;
                        ellipsoid.rotation.z += 0.005;
                        
                        // 张量分量动态变化
                        const time = Date.now() * 0.001;
                        const geometricRelation = ellipsoid.userData.geometricRelation + Math.sin(time + i) * 0.1;
                        const phaseRelation = ellipsoid.userData.phaseRelation + Math.cos(time * 1.3 + i) * 0.1;
                        const energyRelation = ellipsoid.userData.energyRelation + Math.sin(time * 0.7 + i) * 0.1;
                        
                        // 更新椭球体缩放
                        ellipsoid.scale.set(
                            Math.max(0.1, geometricRelation * 2),
                            Math.max(0.1, Math.abs(phaseRelation) * 2),
                            Math.max(0.1, energyRelation * 2)
                        );
                        
                        // 更新颜色
                        const hue = (geometricRelation + phaseRelation + energyRelation) / 3 * 0.3;
                        ellipsoid.material.color.setHSL(hue, 1, 0.7);
                    });
                }
                
                // 张量场动画
                if (tensorFieldActive) {
                    tensorField.forEach((arrow, i) => {
                        // 场向量旋转
                        arrow.rotation.y += 0.01;
                        
                        // 场强度变化
                        const time = Date.now() * 0.001;
                        const fieldStrength = arrow.userData.fieldStrength + Math.sin(time + i) * 0.1;
                        
                        // 更新箭头长度
                        const newLength = Math.max(0.5, fieldStrength * 3);
                        arrow.scale.y = newLength / 3; // 原始长度为3
                        
                        // 更新颜色
                        arrow.material.color.setHSL(fieldStrength * 0.3, 1, 0.7);
                    });
                }
                
                // 张量流动画
                if (tensorFlowActive) {
                    tensorFlowParticles.forEach(particle => {
                        // 粒子运动
                        particle.position.add(particle.userData.velocity);
                        
                        // 张量流相位变化
                        particle.userData.flowPhase += 0.02;
                        
                        // 基于张量值的螺旋运动
                        const tensorValue = particle.userData.tensorValue;
                        const phase = particle.userData.flowPhase;
                        
                        particle.position.x += Math.sin(phase) * tensorValue * 0.01;
                        particle.position.y += Math.cos(phase) * tensorValue * 0.01;
                        particle.position.z += Math.sin(phase * 0.5) * tensorValue * 0.005;
                        
                        // 边界检测
                        if (Math.abs(particle.position.x) > 30) particle.userData.velocity.x *= -1;
                        if (Math.abs(particle.position.y) > 30) particle.userData.velocity.y *= -1;
                        if (Math.abs(particle.position.z) > 30) particle.userData.velocity.z *= -1;
                        
                        // 张量值影响颜色和大小
                        particle.material.color.setHSL(0.1 + tensorValue * 0.1, 1, 0.7);
                        const scale = 0.5 + tensorValue * 0.5;
                        particle.scale.setScalar(scale);
                    });
                }
                
                // 哥白尼计划双路径验证动画
                if (dualPathVerificationActive) {
                    // 反推路径节点动画
                    reversePathNodes.forEach((node, i) => {
                        node.userData.verificationPhase += 0.02;
                        const phase = node.userData.verificationPhase;
                        
                        // 节点旋转
                        node.rotation.y += 0.01;
                        node.rotation.x += 0.005;
                        
                        // 节点亮度变化
                        node.material.opacity = 0.8 + Math.sin(phase) * 0.2;
                        
                        // 节点上下浮动
                        node.position.y = Math.sin(phase) * 2;
                    });
                    
                    // 正推路径节点动画
                    forwardPathNodes.forEach((node, i) => {
                        node.userData.verificationPhase += 0.02;
                        const phase = node.userData.verificationPhase;
                        
                        // 节点旋转
                        node.rotation.y += 0.01;
                        node.rotation.x += 0.005;
                        
                        // 节点亮度变化
                        node.material.opacity = 0.8 + Math.sin(phase) * 0.2;
                        
                        // 节点上下浮动
                        node.position.y = Math.sin(phase) * 2;
                    });
                    
                    // 验证连接线动画
                    verificationConnections.forEach((connection, i) => {
                        const reverseNode = reversePathNodes[i];
                        const forwardNode = forwardPathNodes[i];
                        
                        // 更新连接线位置
                        connection.geometry.setFromPoints([
                            reverseNode.position,
                            forwardNode.position
                        ]);
                        
                        // 连接线闪烁
                        connection.material.opacity = 0.6 + Math.sin(Date.now() * 0.002 + i) * 0.3;
                    });
                    
                    // 数据流粒子动画
                    dualPathDataFlowParticles.forEach((particle, i) => {
                        const pathNodes = particle.userData.pathType === 'reverse' ? reversePathNodes : forwardPathNodes;
                        const currentNode = particle.userData.currentNode;
                        const nextNode = (currentNode + 1) % pathNodes.length;
                        
                        const currentPos = pathNodes[currentNode].position;
                        const nextPos = pathNodes[nextNode].position;
                        
                        // 粒子在路径上移动
                        const progress = (Date.now() * 0.001 * particle.userData.flowSpeed) % 1;
                        particle.position.lerpVectors(currentPos, nextPos, progress);
                        
                        // 粒子到达下一个节点时更新
                        if (progress > 0.95) {
                            particle.userData.currentNode = nextNode;
                        }
                        
                        // 粒子旋转
                        particle.rotation.y += 0.05;
                        particle.rotation.x += 0.02;
                    });
                }
                
                // 单独的反推路径动画
                if (reversePathActive) {
                    reversePathNodes.forEach((node, i) => {
                        node.userData.verificationPhase += 0.02;
                        const phase = node.userData.verificationPhase;
                        
                        node.rotation.y += 0.01;
                        node.material.opacity = 0.8 + Math.sin(phase) * 0.2;
                        node.position.y = Math.sin(phase) * 2;
                    });
                }
                
                // 单独的正推路径动画
                if (forwardPathActive) {
                    forwardPathNodes.forEach((node, i) => {
                        node.userData.verificationPhase += 0.02;
                        const phase = node.userData.verificationPhase;
                        
                        node.rotation.y += 0.01;
                        node.material.opacity = 0.8 + Math.sin(phase) * 0.2;
                        node.position.y = Math.sin(phase) * 2;
                    });
                }
                
                // 量子涨落动画
                if (quantumFluctuationsActive) {
                    quantumFluctuationParticles.forEach((particle, i) => {
                        const userData = particle.userData;
                        userData.fluctuationPhase += userData.fluctuationFrequency * 0.02;
                        
                        // 量子涨落运动
                        const phase = userData.fluctuationPhase;
                        const amplitude = userData.fluctuationAmplitude;
                        
                        // 基于量子态的涨落模式
                        if (userData.quantumState === 'excited') {
                            // 激发态：更大的涨落
                            particle.position.x = userData.originalPosition.x + Math.sin(phase) * amplitude * 2;
                            particle.position.y = userData.originalPosition.y + Math.cos(phase * 1.3) * amplitude * 2;
                            particle.position.z = userData.originalPosition.z + Math.sin(phase * 0.7) * amplitude * 2;
                        } else {
                            // 基态：较小的涨落
                            particle.position.x = userData.originalPosition.x + Math.sin(phase) * amplitude * 0.5;
                            particle.position.y = userData.originalPosition.y + Math.cos(phase * 1.3) * amplitude * 0.5;
                            particle.position.z = userData.originalPosition.z + Math.sin(phase * 0.7) * amplitude * 0.5;
                        }
                        
                        // 量子态随机切换
                        if (Math.random() < 0.001) {
                            userData.quantumState = userData.quantumState === 'excited' ? 'ground' : 'excited';
                        }
                        
                        // 颜色变化
                        const hue = (userData.quantumState === 'excited' ? 0.8 : 0.2) + Math.sin(phase) * 0.1;
                        particle.material.color.setHSL(hue, 1, 0.7);
                        
                        // 透明度变化
                        particle.material.opacity = 0.6 + Math.sin(phase) * 0.3;
                    });
                }
                
                // 真空涨落动画
                if (vacuumFluctuationsActive) {
                    vacuumFluctuationWaves.forEach((wave, i) => {
                        const userData = wave.userData;
                        userData.wavePhase += userData.waveFrequency * 0.02;
                        
                        // 波面变形
                        const positions = wave.geometry.attributes.position.array;
                        const phase = userData.wavePhase;
                        const amplitude = userData.waveAmplitude;
                        
                        for (let j = 0; j < positions.length; j += 3) {
                            const x = positions[j];
                            const y = positions[j + 1];
                            const z = positions[j + 2];
                            
                            // 波面高度变化
                            positions[j + 2] = z + Math.sin(x * 0.5 + phase) * Math.cos(y * 0.5 + phase) * amplitude;
                        }
                        
                        wave.geometry.attributes.position.needsUpdate = true;
                        
                        // 波面颜色变化
                        const hue = 0.6 + Math.sin(phase) * 0.2;
                        wave.material.color.setHSL(hue, 1, 0.5);
                        
                        // 透明度变化
                        wave.material.opacity = 0.3 + Math.sin(phase) * 0.2;
                    });
                }
                
                // 虚粒子动画
                if (virtualParticlesActive) {
                    virtualParticles.forEach((particle, i) => {
                        const userData = particle.userData;
                        userData.age += 0.01;
                        
                        // 虚粒子寿命管理
                        if (userData.age > userData.lifetime) {
                            // 虚粒子湮灭
                            scene.remove(particle);
                            virtualParticles.splice(i, 1);
                            
                            // 如果伙伴粒子还存在，也移除
                            if (userData.partner && virtualParticles.includes(userData.partner)) {
                                scene.remove(userData.partner);
                                const partnerIndex = virtualParticles.indexOf(userData.partner);
                                virtualParticles.splice(partnerIndex, 1);
                            }
                            return;
                        }
                        
                        // 虚粒子运动
                        const lifetimeRatio = userData.age / userData.lifetime;
                        const oscillation = Math.sin(lifetimeRatio * Math.PI * 4) * (1 - lifetimeRatio);
                        
                        particle.position.y += oscillation * 0.1;
                        particle.rotation.y += 0.05;
                        particle.rotation.x += 0.02;
                        
                        // 虚粒子颜色变化（基于寿命）
                        const alpha = 1 - lifetimeRatio;
                        particle.material.opacity = alpha * 0.8;
                        
                        // 虚粒子大小变化
                        const scale = 0.5 + (1 - lifetimeRatio) * 0.5;
                        particle.scale.setScalar(scale);
                    });
                }

                // 视角切换
                if (viewMode === 'front') {
                    camera.position.set(0, 0, 80);
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                } else if (viewMode === 'side') {
                    camera.position.set(80, 0, 0);
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                } else if (viewMode === 'rotate') {
                    rotationAngle += 0.0015;
                    camera.position.x = 80 * Math.sin(rotationAngle);
                    camera.position.z = 80 * Math.cos(rotationAngle);
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                } else if (viewMode === 'zoom') {
                    zoomLevel += Math.sin(Date.now() * 0.0004) * 1;
                    camera.position.z = Math.max(10, Math.min(500, zoomLevel));
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                } else if (viewMode === 'rotateZoom') {
                    rotationAngle += 0.0015;
                    zoomLevel += Math.sin(Date.now() * 0.0004) * 1;
                    camera.position.x = Math.max(10, Math.min(500, zoomLevel)) * Math.sin(rotationAngle);
                    camera.position.z = Math.max(10, Math.min(500, zoomLevel)) * Math.cos(rotationAngle);
                    camera.position.y = Math.sin(Date.now() * 0.0004) * 10;
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                } else if (viewMode === 'manual') {
                    rotationAngle += manualRotationSpeed;
                    camera.position.x = manualZoom * Math.sin(rotationAngle);
                    camera.position.z = manualZoom * Math.cos(rotationAngle);
                    camera.position.y = Math.sin(Date.now() * 0.0004) * 10;
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                    console.log(`相机位置: x=${camera.position.x.toFixed(2)}, z=${camera.position.z.toFixed(2)}`);
                } else if (viewMode === 'sphere360') {
                    // 360度球体滚动视角
                    sphereAngleX += sphereSpeed;
                    sphereAngleY += sphereSpeed * 0.7; // Y轴滚动稍慢，创造更自然的球体运动
                    
                    // 球面坐标计算
                    const x = sphereRadius * Math.sin(sphereAngleY) * Math.cos(sphereAngleX);
                    const y = sphereRadius * Math.cos(sphereAngleY);
                    const z = sphereRadius * Math.sin(sphereAngleY) * Math.sin(sphereAngleX);
                    
                    camera.position.set(x, y, z);
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                    
                    // 添加轻微的上下浮动，模拟球体滚动
                    camera.position.y += Math.sin(Date.now() * 0.0003) * 5;
                } else if (viewMode === 'free') {
                    // 自由视角：鼠标控制，不自动更新相机位置
                    // 相机位置由鼠标事件控制
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                }

                renderer.render(scene, camera);
            }
            animate();

            // 鼠标滚轮缩放
            let mouseWheelZoom = 80;
            const minZoom = 10;
            const maxZoom = 500;
            
            // 鼠标拖拽旋转
            let isMouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let mouseRotationX = 0;
            let mouseRotationY = 0;
            
            window.addEventListener('wheel', (event) => {
                event.preventDefault();
                
                // 根据滚轮方向调整缩放
                if (event.deltaY < 0) {
                    mouseWheelZoom = Math.max(minZoom, mouseWheelZoom - 5);
                } else {
                    mouseWheelZoom = Math.min(maxZoom, mouseWheelZoom + 5);
                }
                
                // 更新相机位置
                if (viewMode === 'front' || viewMode === 'side') {
                    camera.position.z = mouseWheelZoom;
                } else if (viewMode === 'rotate' || viewMode === 'rotateZoom') {
                    camera.position.x = mouseWheelZoom * Math.sin(rotationAngle);
                    camera.position.z = mouseWheelZoom * Math.cos(rotationAngle);
                } else if (viewMode === 'zoom') {
                    camera.position.z = mouseWheelZoom;
                } else if (viewMode === 'manual') {
                    camera.position.x = mouseWheelZoom * Math.sin(rotationAngle);
                    camera.position.z = mouseWheelZoom * Math.cos(rotationAngle);
                } else if (viewMode === 'sphere360') {
                    sphereRadius = mouseWheelZoom;
                } else if (viewMode === 'free') {
                    // 自由视角：更新相机位置
                    const radius = mouseWheelZoom;
                    camera.position.x = radius * Math.sin(mouseRotationY) * Math.cos(mouseRotationX);
                    camera.position.y = radius * Math.sin(mouseRotationX);
                    camera.position.z = radius * Math.cos(mouseRotationY) * Math.cos(mouseRotationX);
                }
                
                // 更新信息显示
                document.getElementById('info').textContent = `鼠标滚轮缩放: ${mouseWheelZoom.toFixed(0)}`;
            });
            
            // 鼠标拖拽旋转事件
            window.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            window.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            window.addEventListener('mousemove', (event) => {
                if (isMouseDown && viewMode === 'free') {
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    mouseRotationX += deltaY * 0.01;
                    mouseRotationY += deltaX * 0.01;
                    
                    // 限制垂直旋转角度
                    mouseRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseRotationX));
                    
                    // 更新相机位置
                    const radius = mouseWheelZoom;
                    camera.position.x = radius * Math.sin(mouseRotationY) * Math.cos(mouseRotationX);
                    camera.position.y = radius * Math.sin(mouseRotationX);
                    camera.position.z = radius * Math.cos(mouseRotationY) * Math.cos(mouseRotationX);
                    
                    camera.lookAt(0, subUniverseGenerated ? 30 : 0, 0);
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                    
                    // 更新信息显示
                    document.getElementById('info').textContent = `自由视角: 旋转X=${(mouseRotationX * 180 / Math.PI).toFixed(1)}°, Y=${(mouseRotationY * 180 / Math.PI).toFixed(1)}°, 缩放=${mouseWheelZoom.toFixed(0)}`;
                }
            });

            // 键盘快捷键
            window.addEventListener('keydown', (event) => {
                if (event.key === 'h' || event.key === 'H') {
                    // H键：隐藏/显示控制面板
                    toggleControls();
                } else if (event.key === 'i' || event.key === 'I') {
                    // I键：隐藏/显示使用说明
                    toggleInstructions();
                } else if (event.key === 'g' || event.key === 'G') {
                    // G键：隐藏/显示详细说明
                    toggleDetailedGuide();
                } else if (event.key === 'r' || event.key === 'R') {
                    // R键：重置视角
                    resetView();
                } else if (event.key === 'm' || event.key === 'M') {
                    // M键：隐藏/显示数学结构可视化
                    toggleMathVisualization();
                } else if (event.key === '1') {
                    // 数字1：显示哈密顿量矩阵
                    showHamiltonianMatrix();
                } else if (event.key === '2') {
                    // 数字2：显示关系张量
                    showTensorVisualization();
                } else if (event.key === '3') {
                    // 数字3：显示贝塔函数
                    showBetaFunction();
                } else if (event.key === '4') {
                    // 数字4：显示物理常数
                    showPhysicalConstants();
                } else if (event.key === 'o' || event.key === 'O') {
                    // O键：创建观察者节点
                    createObserverNode();
                } else if (event.key === 'p' || event.key === 'P') {
                    // P键：激活观察者模式
                    activateObserverMode();
                } else if (event.key === 'e' || event.key === 'E') {
                    // E键：显示内禀能量
                    showIntrinsicEnergy();
                } else if (event.key === 'f' || event.key === 'F') {
                    // F键：显示能量流动
                    showEnergyFlow();
                } else if (event.key === 'd' || event.key === 'D') {
                    // D键：显示能量密度
                    showEnergyDensity();
                } else if (event.key === 't' || event.key === 'T') {
                    // T键：显示3D张量几何
                    showTensor3DGeometry();
                } else if (event.key === 'y' || event.key === 'Y') {
                    // Y键：显示张量场
                    showTensorField();
                } else if (event.key === 'u' || event.key === 'U') {
                    // U键：显示张量流
                    showTensorFlow();
                } else if (event.key === 'c' || event.key === 'C') {
                    // C键：显示双路径验证
                    showDualPathVerification();
                } else if (event.key === 'v' || event.key === 'V') {
                    // V键：显示反推路径
                    showReversePath();
                } else if (event.key === 'b' || event.key === 'B') {
                    // B键：显示正推路径
                    showForwardPath();
                } else if (event.key === 'q' || event.key === 'Q') {
                    // Q键：显示量子涨落
                    showQuantumFluctuations();
                } else if (event.key === 'w' || event.key === 'W') {
                    // W键：显示真空涨落
                    showVacuumFluctuations();
                } else if (event.key === 'x' || event.key === 'X') {
                    // X键：显示虚粒子
                    showVirtualParticles();
                }
            });

            // 窗口自适应
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // 数学结构可视化函数
            function toggleMathVisualization() {
                const mathPanel = document.getElementById('mathVisualization');
                if (mathPanel.style.display === 'none') {
                    mathPanel.style.display = 'block';
                } else {
                    mathPanel.style.display = 'none';
                }
            }
            
            function showHamiltonianMatrix() {
                const mathPanel = document.getElementById('mathVisualization');
                const hamiltonianDisplay = document.getElementById('hamiltonianDisplay');
                
                mathPanel.style.display = 'block';
                hamiltonianDisplay.style.display = 'block';
                
                // 动态更新哈密顿量参数
                updateHamiltonianValues();
                document.getElementById('info').textContent = '显示哈密顿量矩阵 H_dyn';
            }
            
            function showTensorVisualization() {
                const mathPanel = document.getElementById('mathVisualization');
                const tensorDisplay = document.getElementById('tensorDisplay');
                
                mathPanel.style.display = 'block';
                tensorDisplay.style.display = 'block';
                
                // 动态更新张量参数
                updateTensorValues();
                document.getElementById('info').textContent = '显示关系张量 T_ij';
            }
            
            function showBetaFunction() {
                const mathPanel = document.getElementById('mathVisualization');
                const betaDisplay = document.getElementById('betaFunctionDisplay');
                
                mathPanel.style.display = 'block';
                betaDisplay.style.display = 'block';
                
                // 动态更新贝塔函数参数
                updateBetaFunctionValues();
                document.getElementById('info').textContent = '显示贝塔函数演化';
            }
            
            function showPhysicalConstants() {
                const mathPanel = document.getElementById('mathVisualization');
                const constantsDisplay = document.getElementById('physicalConstantsDisplay');
                
                mathPanel.style.display = 'block';
                constantsDisplay.style.display = 'block';
                
                // 动态更新物理常数
                updatePhysicalConstants();
                document.getElementById('info').textContent = '显示物理常数涌现';
            }
            
            // 动态更新函数
            function updateHamiltonianValues() {
                const couplingValue = document.getElementById('couplingValue');
                const localEnergy = document.getElementById('localEnergy');
                const fluctuationValue = document.getElementById('fluctuationValue');
                
                // 基于网络状态计算参数
                const nodeCount = motherNodes.length;
                const avgCoupling = Math.max(0.1, 0.5 - (nodeCount - 100) / 1000);
                const avgEnergy = 1.0 + Math.sin(Date.now() * 0.001) * 0.2;
                const fluctuation = 0.1 + Math.sin(Date.now() * 0.002) * 0.05;
                
                if (couplingValue) couplingValue.textContent = avgCoupling.toFixed(3);
                if (localEnergy) localEnergy.textContent = avgEnergy.toFixed(3);
                if (fluctuationValue) fluctuationValue.textContent = fluctuation.toFixed(3);
            }
            
            function updateTensorValues() {
                const geometricRelation = document.getElementById('geometricRelation');
                const phaseRelation = document.getElementById('phaseRelation');
                const energyRelation = document.getElementById('energyRelation');
                
                // 基于网络几何计算张量分量
                const geometric = 1.0 + Math.sin(Date.now() * 0.001) * 0.1;
                const phase = Math.sin(Date.now() * 0.002) * Math.PI;
                const energy = 0.5 + Math.sin(Date.now() * 0.0015) * 0.2;
                
                if (geometricRelation) geometricRelation.textContent = geometric.toFixed(3);
                if (phaseRelation) phaseRelation.textContent = phase.toFixed(3);
                if (energyRelation) energyRelation.textContent = energy.toFixed(3);
            }
            
            function updateBetaFunctionValues() {
                const energyScale = document.getElementById('energyScale');
                const fluctuationStrength = document.getElementById('fluctuationStrength');
                const betaRate = document.getElementById('betaRate');
                
                // 基于当前网络状态计算贝塔函数参数
                const scale = 100 + Math.sin(Date.now() * 0.0005) * 10;
                const strength = 0.2 + Math.sin(Date.now() * 0.001) * 0.1;
                const rate = 0.05 + Math.sin(Date.now() * 0.0015) * 0.02;
                
                if (energyScale) energyScale.textContent = scale.toFixed(1);
                if (fluctuationStrength) fluctuationStrength.textContent = strength.toFixed(3);
                if (betaRate) betaRate.textContent = rate.toFixed(3);
            }
            
            function updatePhysicalConstants() {
                const lightSpeed = document.getElementById('lightSpeed');
                const restMass = document.getElementById('restMass');
                const gravitationalConstant = document.getElementById('gravitationalConstant');
                const planckConstant = document.getElementById('planckConstant');
                const fineStructureConstant = document.getElementById('fineStructureConstant');
                const electronMass = document.getElementById('electronMass');
                const protonMass = document.getElementById('protonMass');
                const neutronMass = document.getElementById('neutronMass');
                const weakCoupling = document.getElementById('weakCoupling');
                const strongCoupling = document.getElementById('strongCoupling');
                
                // 基于QSDT公式计算物理常数
                const time = Date.now() * 0.001;
                const quantumFluctuation = 0.1 + Math.sin(time * 0.1) * 0.05;
                
                const c = 299792458; // 光速常数
                const mass = 0.5 + Math.sin(time) * 0.1;
                const G = 6.67e-11; // 引力常数
                const hbar = 1.05e-34; // 普朗克常数
                const alpha = 0.007297 + quantumFluctuation * 0.001; // 精细结构常数
                const m_e = 0.511 + quantumFluctuation * 0.01; // 电子质量
                const m_p = 938.3 + quantumFluctuation * 0.1; // 质子质量
                const m_n = 939.6 + quantumFluctuation * 0.1; // 中子质量
                const g_W = 0.65 + quantumFluctuation * 0.05; // 弱相互作用常数
                const g_s = 1.2 + quantumFluctuation * 0.1; // 强相互作用常数
                
                if (lightSpeed) lightSpeed.textContent = c.toExponential(2);
                if (restMass) restMass.textContent = mass.toFixed(3);
                if (gravitationalConstant) gravitationalConstant.textContent = G.toExponential(2);
                if (planckConstant) planckConstant.textContent = hbar.toExponential(2);
                if (fineStructureConstant) fineStructureConstant.textContent = alpha.toFixed(6);
                if (electronMass) electronMass.textContent = m_e.toFixed(3);
                if (protonMass) protonMass.textContent = m_p.toFixed(1);
                if (neutronMass) neutronMass.textContent = m_n.toFixed(1);
                if (weakCoupling) weakCoupling.textContent = g_W.toFixed(3);
                if (strongCoupling) strongCoupling.textContent = g_s.toFixed(3);
            }
            
            // 观察者系统函数
            function createObserverNode() {
                // 清除现有的观察者
                observerNodes.forEach(node => scene.remove(node));
                observerConnections.forEach(conn => scene.remove(conn));
                observerInfluence.forEach(influence => scene.remove(influence));
                observerNodes.length = 0;
                observerConnections.length = 0;
                observerInfluence.length = 0;
                
                // 创建观察者节点
                const observerNode = new THREE.Mesh(
                    new THREE.SphereGeometry(0.8, 16, 16),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xff00ff, 
                        shininess: 100,
                        transparent: true,
                        opacity: 0.9
                    })
                );
                observerNode.position.set(
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 40,
                    (Math.random() - 0.5) * 40
                );
                observerNode.userData = { 
                    observerId: observerCount++,
                    influenceRadius: observerInfluenceRange,
                    observationPhase: 0,
                    isActive: true
                };
                scene.add(observerNode);
                observerNodes.push(observerNode);
                
                // 创建观察者影响范围
                const influenceSphere = new THREE.Mesh(
                    new THREE.SphereGeometry(observerInfluenceRange, 16, 16),
                    new THREE.MeshPhongMaterial({ 
                        color: 0xff00ff, 
                        transparent: true,
                        opacity: 0.1,
                        wireframe: true
                    })
                );
                influenceSphere.position.copy(observerNode.position);
                scene.add(influenceSphere);
                observerInfluence.push(influenceSphere);
                
                observerActive = true;
                document.getElementById('info').textContent = `创建观察者节点 #${observerNode.userData.observerId}`;
            }
            
            function activateObserverMode() {
                observerMode = !observerMode;
                if (observerMode) {
                    document.getElementById('info').textContent = '观察者模式激活：观察改变网络状态';
                    // 激活观察者模式时，网络会根据观察者位置调整
                    updateNetworkBasedOnObservers();
                } else {
                    document.getElementById('info').textContent = '观察者模式关闭';
                }
            }
            
            function showObserverInfluence() {
                // 显示观察者对网络的影响
                if (observerNodes.length === 0) {
                    document.getElementById('info').textContent = '请先创建观察者节点';
                    return;
                }
                
                // 创建观察者与网络节点的连接
                observerNodes.forEach((observer, i) => {
                    const nearbyNodes = motherNodes.filter(node => 
                        node.position.distanceTo(observer.position) < observerInfluenceRange
                    );
                    
                    nearbyNodes.forEach(node => {
                        const geometry = new THREE.BufferGeometry().setFromPoints([
                            observer.position,
                            node.position
                        ]);
                        const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                            color: 0xff00ff, 
                            transparent: true, 
                            opacity: 0.3 
                        }));
                        scene.add(connection);
                        observerConnections.push(connection);
                    });
                });
                
                document.getElementById('info').textContent = `显示观察者影响：${observerConnections.length}个连接`;
            }
            
            function updateNetworkBasedOnObservers() {
                if (!observerMode) return;
                
                // 观察者影响网络节点的行为
                motherNodes.forEach(node => {
                    observerNodes.forEach(observer => {
                        const distance = node.position.distanceTo(observer.position);
                        if (distance < observerInfluenceRange) {
                            // 观察者影响：节点向观察者方向轻微移动
                            const direction = new THREE.Vector3()
                                .subVectors(observer.position, node.position)
                                .normalize()
                                .multiplyScalar(0.01);
                            node.position.add(direction);
                            
                            // 观察者影响：改变节点颜色
                            const influence = 1 - (distance / observerInfluenceRange);
                            node.material.color.setHSL(0.3, 1, 0.5 + influence * 0.5);
                        }
                    });
                });
            }
            
            // 内禀能量可视化函数
            function showIntrinsicEnergy() {
                // 清除现有的能量可视化
                energySpheres.forEach(sphere => scene.remove(sphere));
                energyConnections.forEach(conn => scene.remove(conn));
                energySpheres.length = 0;
                energyConnections.length = 0;
                
                // 为每个网络节点创建内禀能量球
                motherNodes.forEach((node, i) => {
                    // 计算内禀能量 E_i (基于QSDT理论)
                    const intrinsicEnergy = 1.0 + Math.sin(i * 0.1) * 0.5; // 模拟内禀能量变化
                    const energyRadius = 0.2 + intrinsicEnergy * 0.3; // 能量越大，球体越大
                    
                    // 创建能量球
                    const energySphere = new THREE.Mesh(
                        new THREE.SphereGeometry(energyRadius, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: new THREE.Color().setHSL(intrinsicEnergy * 0.3, 1, 0.7),
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
                    // 能量球位置在节点上方
                    energySphere.position.copy(node.position);
                    energySphere.position.y += 2;
                    energySphere.userData = { 
                        nodeIndex: i, 
                        intrinsicEnergy: intrinsicEnergy,
                        originalY: energySphere.position.y
                    };
                    
                    scene.add(energySphere);
                    energySpheres.push(energySphere);
                    
                    // 创建能量连接线
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        node.position,
                        energySphere.position
                    ]);
                    const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                        color: new THREE.Color().setHSL(intrinsicEnergy * 0.3, 1, 0.7),
                        transparent: true, 
                        opacity: 0.6 
                    }));
                    scene.add(connection);
                    energyConnections.push(connection);
                });
                
                intrinsicEnergyActive = true;
                document.getElementById('info').textContent = `显示内禀能量：${energySpheres.length}个能量球`;
            }
            
            function showEnergyFlow() {
                // 清除现有的能量流动
                energyFlowParticles.forEach(particle => scene.remove(particle));
                energyFlowParticles.length = 0;
                
                // 创建能量流动粒子
                for (let i = 0; i < 20; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 6, 6),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
                    // 随机起始位置
                    particle.position.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1
                        ),
                        energy: Math.random() * 2 + 0.5
                    };
                    
                    scene.add(particle);
                    energyFlowParticles.push(particle);
                }
                
                energyFlowActive = true;
                document.getElementById('info').textContent = `显示能量流动：${energyFlowParticles.length}个流动粒子`;
            }
            
            function showEnergyDensity() {
                // 基于网络密度显示能量密度
                const densityRegions = [];
                const gridSize = 10;
                
                for (let x = -30; x < 30; x += gridSize) {
                    for (let y = -30; y < 30; y += gridSize) {
                        for (let z = -30; z < 30; z += gridSize) {
                            // 计算该区域的节点密度
                            const regionCenter = new THREE.Vector3(x, y, z);
                            let nodeCount = 0;
                            
                            motherNodes.forEach(node => {
                                if (node.position.distanceTo(regionCenter) < gridSize) {
                                    nodeCount++;
                                }
                            });
                            
                            if (nodeCount > 0) {
                                const density = nodeCount / 10; // 归一化密度
                                const densityBox = new THREE.Mesh(
                                    new THREE.BoxGeometry(gridSize * 0.8, gridSize * 0.8, gridSize * 0.8),
                                    new THREE.MeshPhongMaterial({ 
                                        color: new THREE.Color().setHSL(0.6, 1, 0.5 + density * 0.3),
                                        transparent: true,
                                        opacity: 0.3 + density * 0.4
                                    })
                                );
                                densityBox.position.copy(regionCenter);
                                scene.add(densityBox);
                                densityRegions.push(densityBox);
                            }
                        }
                    }
                }
                
                energyDensityActive = true;
                document.getElementById('info').textContent = `显示能量密度：${densityRegions.length}个密度区域`;
            }
            
            // 张量几何可视化函数
            function showTensor3DGeometry() {
                // 清除现有的张量几何
                tensorGeometry.forEach(geometry => scene.remove(geometry));
                tensorGeometry.length = 0;
                
                // 为每个网络连接创建3D张量几何
                motherEdges.forEach((edge, i) => {
                    const startNode = motherNodes[edge.startIdx];
                    const endNode = motherNodes[edge.endIdx];
                    
                    // 计算张量分量 T_ij = R_ij ⊗ θ_ij ⊗ J_ij
                    const distance = startNode.position.distanceTo(endNode.position);
                    const geometricRelation = 1.0 / (1.0 + distance * 0.1); // R_ij
                    const phaseRelation = Math.sin(i * 0.1); // θ_ij
                    const energyRelation = 0.5 + Math.sin(i * 0.2) * 0.3; // J_ij
                    
                    // 创建张量椭球体
                    const tensorScale = new THREE.Vector3(
                        geometricRelation * 2,
                        Math.abs(phaseRelation) * 2,
                        energyRelation * 2
                    );
                    
                    const tensorEllipsoid = new THREE.Mesh(
                        new THREE.SphereGeometry(1, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: new THREE.Color().setHSL(
                                (geometricRelation + phaseRelation + energyRelation) / 3 * 0.3, 
                                1, 
                                0.7
                            ),
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    
                    // 张量椭球体位置在连接中点
                    const midPoint = new THREE.Vector3()
                        .addVectors(startNode.position, endNode.position)
                        .multiplyScalar(0.5);
                    tensorEllipsoid.position.copy(midPoint);
                    tensorEllipsoid.scale.copy(tensorScale);
                    
                    tensorEllipsoid.userData = {
                        geometricRelation: geometricRelation,
                        phaseRelation: phaseRelation,
                        energyRelation: energyRelation,
                        originalScale: tensorScale.clone()
                    };
                    
                    scene.add(tensorEllipsoid);
                    tensorGeometry.push(tensorEllipsoid);
                });
                
                tensor3DGeometryActive = true;
                document.getElementById('info').textContent = `显示3D张量几何：${tensorGeometry.length}个张量椭球`;
            }
            
            function showTensorField() {
                // 清除现有的张量场
                tensorField.forEach(field => scene.remove(field));
                tensorField.length = 0;
                
                // 创建张量场网格
                const gridSize = 8;
                const fieldSize = 40;
                
                for (let x = -fieldSize; x < fieldSize; x += gridSize) {
                    for (let y = -fieldSize; y < fieldSize; y += gridSize) {
                        for (let z = -fieldSize; z < fieldSize; z += gridSize) {
                            const position = new THREE.Vector3(x, y, z);
                            
                            // 计算该位置的张量场强度
                            let fieldStrength = 0;
                            motherNodes.forEach(node => {
                                const distance = node.position.distanceTo(position);
                                if (distance < 20) {
                                    fieldStrength += 1.0 / (1.0 + distance * 0.1);
                                }
                            });
                            
                            if (fieldStrength > 0.1) {
                                // 创建张量场箭头
                                const arrowLength = fieldStrength * 3;
                                const arrowGeometry = new THREE.ConeGeometry(0.2, arrowLength, 6);
                                const arrowMaterial = new THREE.MeshPhongMaterial({ 
                                    color: new THREE.Color().setHSL(fieldStrength * 0.3, 1, 0.7),
                                    transparent: true,
                                    opacity: 0.7
                                });
                                
                                const arrow = new THREE.Mesh(arrowGeometry, arrowMaterial);
                                arrow.position.copy(position);
                                
                                // 箭头方向基于局部张量梯度
                                const gradient = new THREE.Vector3(
                                    Math.sin(x * 0.1) * fieldStrength,
                                    Math.cos(y * 0.1) * fieldStrength,
                                    Math.sin(z * 0.1) * fieldStrength
                                ).normalize();
                                
                                arrow.lookAt(
                                    position.x + gradient.x * arrowLength,
                                    position.y + gradient.y * arrowLength,
                                    position.z + gradient.z * arrowLength
                                );
                                
                                arrow.userData = {
                                    fieldStrength: fieldStrength,
                                    gradient: gradient
                                };
                                
                                scene.add(arrow);
                                tensorField.push(arrow);
                            }
                        }
                    }
                }
                
                tensorFieldActive = true;
                document.getElementById('info').textContent = `显示张量场：${tensorField.length}个场向量`;
            }
            
            function showTensorFlow() {
                // 清除现有的张量流
                tensorFlowParticles.forEach(particle => scene.remove(particle));
                tensorFlowParticles.length = 0;
                
                // 创建张量流粒子
                for (let i = 0; i < 30; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 6, 6),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff6600,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
                    // 随机起始位置
                    particle.position.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    
                    particle.userData = {
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.05,
                            (Math.random() - 0.5) * 0.05
                        ),
                        tensorValue: Math.random() * 2 + 0.5,
                        flowPhase: Math.random() * Math.PI * 2
                    };
                    
                    scene.add(particle);
                    tensorFlowParticles.push(particle);
                }
                
                tensorFlowActive = true;
                document.getElementById('info').textContent = `显示张量流：${tensorFlowParticles.length}个流粒子`;
            }
            
            // 哥白尼计划双路径验证函数
            function showDualPathVerification() {
                // 清除现有的验证路径
                reversePathNodes.forEach(node => scene.remove(node));
                forwardPathNodes.forEach(node => scene.remove(node));
                verificationConnections.forEach(conn => scene.remove(conn));
                dualPathDataFlowParticles.forEach(particle => scene.remove(particle));
                reversePathNodes.length = 0;
                forwardPathNodes.length = 0;
                verificationConnections.length = 0;
                dualPathDataFlowParticles.length = 0;
                
                // 创建反推路径节点（红色 - 从实验数据反推）
                for (let i = 0; i < 6; i++) {
                    const reverseNode = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff0000,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
                    const angle = (i / 6) * Math.PI * 2;
                    reverseNode.position.set(
                        Math.cos(angle) * 25,
                        0,
                        Math.sin(angle) * 25
                    );
                    
                    reverseNode.userData = {
                        pathType: 'reverse',
                        step: i,
                        verificationPhase: i * Math.PI / 3
                    };
                    
                    scene.add(reverseNode);
                    reversePathNodes.push(reverseNode);
                }
                
                // 创建正推路径节点（绿色 - 从理论预测正推）
                for (let i = 0; i < 6; i++) {
                    const forwardNode = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ff00,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
                    const angle = (i / 6) * Math.PI * 2 + Math.PI / 6; // 偏移30度
                    forwardNode.position.set(
                        Math.cos(angle) * 25,
                        0,
                        Math.sin(angle) * 25
                    );
                    
                    forwardNode.userData = {
                        pathType: 'forward',
                        step: i,
                        verificationPhase: i * Math.PI / 3
                    };
                    
                    scene.add(forwardNode);
                    forwardPathNodes.push(forwardNode);
                }
                
                // 创建验证连接线
                for (let i = 0; i < 6; i++) {
                    const reverseNode = reversePathNodes[i];
                    const forwardNode = forwardPathNodes[i];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints([
                        reverseNode.position,
                        forwardNode.position
                    ]);
                    const connection = new THREE.Line(geometry, new THREE.LineBasicMaterial({ 
                        color: 0xffff00,
                        transparent: true, 
                        opacity: 0.6 
                    }));
                    scene.add(connection);
                    verificationConnections.push(connection);
                }
                
                // 创建数据流粒子
                for (let i = 0; i < 12; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.2, 6, 6),
                        new THREE.MeshPhongMaterial({ 
                            color: i < 6 ? 0xff0000 : 0x00ff00,
                            transparent: true,
                            opacity: 0.9
                        })
                    );
                    
                    const pathNodes = i < 6 ? reversePathNodes : forwardPathNodes;
                    const nodeIndex = i % 6;
                    particle.position.copy(pathNodes[nodeIndex].position);
                    
                    particle.userData = {
                        pathType: i < 6 ? 'reverse' : 'forward',
                        currentNode: nodeIndex,
                        flowSpeed: 0.5 + Math.random() * 0.5
                    };
                    
                    scene.add(particle);
                    dualPathDataFlowParticles.push(particle);
                }
                
                dualPathVerificationActive = true;
                document.getElementById('info').textContent = `显示双路径验证：反推路径(红) + 正推路径(绿) + 验证连接(黄)`;
            }
            
            function showReversePath() {
                // 只显示反推路径
                forwardPathNodes.forEach(node => scene.remove(node));
                verificationConnections.forEach(conn => scene.remove(conn));
                forwardPathNodes.length = 0;
                verificationConnections.length = 0;
                
                reversePathActive = true;
                forwardPathActive = false;
                document.getElementById('info').textContent = `显示反推路径：从实验数据反推理论参数`;
            }
            
            function showForwardPath() {
                // 只显示正推路径
                reversePathNodes.forEach(node => scene.remove(node));
                verificationConnections.forEach(conn => scene.remove(conn));
                reversePathNodes.length = 0;
                verificationConnections.length = 0;
                
                forwardPathActive = true;
                reversePathActive = false;
                document.getElementById('info').textContent = `显示正推路径：从理论参数正推物理常数`;
            }
            
            // 量子涨落可视化函数
            function showQuantumFluctuations() {
                // 清除现有的量子涨落
                quantumFluctuationParticles.forEach(particle => scene.remove(particle));
                quantumFluctuationParticles.length = 0;
                
                // 创建量子涨落粒子
                for (let i = 0; i < 50; i++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.1, 6, 6),
                        new THREE.MeshPhongMaterial({ 
                            color: new THREE.Color().setHSL(Math.random(), 1, 0.7),
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    
                    // 随机起始位置
                    particle.position.set(
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    
                    particle.userData = {
                        fluctuationPhase: Math.random() * Math.PI * 2,
                        fluctuationAmplitude: 0.5 + Math.random() * 1.5,
                        fluctuationFrequency: 0.5 + Math.random() * 2.0,
                        originalPosition: particle.position.clone(),
                        quantumState: Math.random() > 0.5 ? 'excited' : 'ground'
                    };
                    
                    scene.add(particle);
                    quantumFluctuationParticles.push(particle);
                }
                
                quantumFluctuationsActive = true;
                document.getElementById('info').textContent = `显示量子涨落：${quantumFluctuationParticles.length}个涨落粒子`;
            }
            
            function showVacuumFluctuations() {
                // 清除现有的真空涨落
                vacuumFluctuationWaves.forEach(wave => scene.remove(wave));
                vacuumFluctuationWaves.length = 0;
                
                // 创建真空涨落波
                for (let i = 0; i < 20; i++) {
                    const wave = new THREE.Mesh(
                        new THREE.PlaneGeometry(20, 20, 32, 32),
                        new THREE.MeshPhongMaterial({ 
                            color: new THREE.Color().setHSL(0.6 + Math.random() * 0.2, 1, 0.5),
                            transparent: true,
                            opacity: 0.3,
                            side: THREE.DoubleSide
                        })
                    );
                    
                    // 随机位置和方向
                    wave.position.set(
                        (Math.random() - 0.5) * 80,
                        (Math.random() - 0.5) * 80,
                        (Math.random() - 0.5) * 80
                    );
                    wave.rotation.set(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    
                    wave.userData = {
                        wavePhase: Math.random() * Math.PI * 2,
                        waveAmplitude: 0.5 + Math.random() * 1.0,
                        waveFrequency: 0.2 + Math.random() * 0.8,
                        originalGeometry: wave.geometry.clone()
                    };
                    
                    scene.add(wave);
                    vacuumFluctuationWaves.push(wave);
                }
                
                vacuumFluctuationsActive = true;
                document.getElementById('info').textContent = `显示真空涨落：${vacuumFluctuationWaves.length}个涨落波`;
            }
            
            function showVirtualParticles() {
                // 清除现有的虚粒子
                virtualParticles.forEach(particle => scene.remove(particle));
                virtualParticles.length = 0;
                
                // 创建虚粒子对
                for (let i = 0; i < 15; i++) {
                    // 虚粒子对
                    const particle1 = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x00ffff,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
  const particle2 = 新 THREE。网格（
                        new THREE.SphereGeometry(0.15, 8, 8),
                        new THREE.MeshPhongMaterial({ 
                            color: 0xff6600,
                            transparent: true,
                            opacity: 0.8
                        })
                    );
                    
                    // 虚粒子对位置
  const centerPos = 新 THREE。矢量 3（
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60,
                        (Math.random() - 0.5) * 60
                    );
                    
                    const separation = 2 + Math.random() * 4;
                    particle1.position.copy(centerPos).add(new THREE.Vector3(separation, 0, 0));
                    particle2.position.copy(centerPos).add(new THREE.Vector3(-separation, 0, 0));
                    
                    particle1.userData = {
                        pairIndex: i,
                        isVirtual: true,
                        lifetime: 0.1 + Math.random() * 0.4,
                        age: 0,
                        partner: particle2
                    };
                    
                    particle2.userData = {
                        pairIndex: i,
                        isVirtual: true,
                        lifetime: particle1.userData.lifetime,
                        age: 0,
                        partner: particle1
                    };
                    
                    scene.add(particle1);
                    scene.add(particle2);
                    virtualParticles.push(particle1, particle2);
                }
                
                virtualParticlesActive = true;
                document.getElementById('info').textContent = `显示虚粒子：${virtualParticles.length}个虚粒子`;
            }
            
            // 初始化生成母宇宙
            generateMotherUniverse();
            updatePerformanceHint();
            
            console.log("场景加载完成！");
        } catch (error) {
            console.error("加载失败：", error);
            document.getElementById('info').textContent = "加载失败，请检查控制台！";
        }
    </script>
</body>
</html>
